diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.def.h" ./config.def.h
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.def.h"	2021-01-13 22:22:32.377160109 +0100
+++ ./config.def.h	2021-01-15 01:24:57.328258658 +0100
@@ -3,97 +3,160 @@
 /* appearance */
 static const unsigned int borderpx  = 1;        /* border pixel of windows */
 static const unsigned int snap      = 32;       /* snap pixel */
+static const int swallowfloating    = 1;        /* 1 means swallow floating windows by default */
+static const unsigned int gappih    = 30;       /* horiz inner gap between windows */
+static const unsigned int gappiv    = 30;       /* vert inner gap between windows */
+static const unsigned int gappoh    = 30;       /* horiz outer gap between windows and screen edge */
+static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+static       int smartgaps          = 1;        /* 1 means no outer gap when there is only one window */
 static const int showbar            = 1;        /* 0 means no bar */
-static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
-static const char col_gray1[]       = "#222222";
-static const char col_gray2[]       = "#444444";
-static const char col_gray3[]       = "#bbbbbb";
-static const char col_gray4[]       = "#eeeeee";
-static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
-};
+static const int topbar             = 0;        /* 0 means bottom bar */
+static const int user_bh            = 32;        /* 0 means that dwm will calculate bar height, >= 1 means dwm will user_bh as bar height */
+static const char *fonts[]          = { "MesloLGS Nerd Font:size=10" };
+static const char dmenufont[]       = "MesloLGS Nerd Font:size=10";
+
+#include "/home/fuzzbox/.cache/wal/colors-wal-dwm.h"
 
 /* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+static const char *tags[] = { "1 ", "2 ", "3 ", "4 ", "5 ", "6 ", "7 ", "8 ", "9 " };
+/* static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }; */
 
 static const Rule rules[] = {
 	/* xprop(1):
 	 *	WM_CLASS(STRING) = instance, class
 	 *	WM_NAME(STRING) = title
 	 */
-	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
+	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
+	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
+	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
+	{ "URxvt",   NULL,     NULL,	       0,	  0,	      1,	   0,	     -1 },
+	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
 };
 
 /* layout(s) */
-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static const float mfact     = 0.5; /* factor of master area size [0.05..0.95] */
 static const int nmaster     = 1;    /* number of clients in master area */
-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
+static const int attachdirection = 0;    /* 0 default, 1 above, 2 aside, 3 below, 4 bottom, 5 top */
+
+
+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+
+#include "vanitygaps.c"
 
 static const Layout layouts[] = {
 	/* symbol     arrange function */
 	{ "[]=",      tile },    /* first entry is default */
-	{ "><>",      NULL },    /* no layout function means floating behavior */
 	{ "[M]",      monocle },
+	{ "[@]",      spiral },
+	{ "[\\]",     dwindle },
+	{ "H[]",      deck },
+	{ "TTT",      bstack },
+	{ "===",      bstackhoriz },
+	{ "HHH",      grid },
+	{ "###",      nrowgrid },
+	{ "---",      horizgrid },
+	{ ":::",      gaplessgrid },
+	{ "|M|",      centeredmaster },
+	{ ">M>",      centeredfloatingmaster },
+	{ "><>",      NULL },    /* no layout function means floating behavior */
+	{ NULL,       NULL },
 };
 
 /* key definitions */
-#define MODKEY Mod1Mask
+#define MODKEY Mod4Mask
 #define TAGKEYS(KEY,TAG) \
 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
 
+#include <X11/XF86keysym.h>
+
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
-static const char *termcmd[]  = { "st", NULL };
+static const char *dmenucmd[]   = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-z", "800", "-p", "Run", NULL };
+static const char *dmenuwdcmd[] = { "dmenu-show-opened-windows", NULL };
+static const char *dmenucpcmd[] = { "clipmenu", "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-p", "Copy", NULL };
+static const char *dmenustcmd[] = { "dmenu-stop", NULL };
+static const char *termcmd[]    = { "urxvt", NULL };
 
 static Key keys[] = {
-	/* modifier                     key        function        argument */
-	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
-	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
-	{ MODKEY,                       XK_b,      togglebar,      {0} },
-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
-	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
-	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
-	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
-	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
-	{ MODKEY,                       XK_Return, zoom,           {0} },
-	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
-	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                       XK_space,  setlayout,      {0} },
-	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
-	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
-	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
-	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
-	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
-	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
-	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
-	TAGKEYS(                        XK_1,                      0)
-	TAGKEYS(                        XK_2,                      1)
-	TAGKEYS(                        XK_3,                      2)
-	TAGKEYS(                        XK_4,                      3)
-	TAGKEYS(                        XK_5,                      4)
-	TAGKEYS(                        XK_6,                      5)
-	TAGKEYS(                        XK_7,                      6)
-	TAGKEYS(                        XK_8,                      7)
-	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	/* modifier                     key        function          argument */
+	{ MODKEY,                       XK_d,      spawn,            {.v = dmenucmd } },
+	{ MODKEY,			XK_w,	   spawn, 	     {.v = dmenuwdcmd } },
+	{ MODKEY,			XK_c,	   spawn,	     {.v = dmenucpcmd } },
+	{ MODKEY,	                XK_Return, spawn,            {.v = termcmd } },
+	{ MODKEY|ShiftMask,		XK_h,	   spawn,	     {.v = dmenustcmd } },
+	{ MODKEY,                       XK_b,      togglebar,        {0} },
+	{ MODKEY,                       XK_k, 	   focusstack,       {.i = +1 } },
+	{ MODKEY,                       XK_j,      focusstack,       {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_k,      pushdown,         {0} },
+	{ MODKEY|ShiftMask,             XK_j,      pushup,           {0} },
+	{ MODKEY,                       XK_i,      incnmaster,       {.i = +1 } },
+	{ MODKEY,                       XK_o,      incnmaster,       {.i = -1 } },
+	{ MODKEY,                       XK_h,      setmfact,         {.f = -0.05} },
+	{ MODKEY,                       XK_l,      setmfact,         {.f = +0.05} },
+	{ MODKEY|ShiftMask,             XK_Return, zoom,             {0} },
+	{ MODKEY|Mod1Mask,              XK_u,      incrgaps,         {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_u,      incrgaps,         {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_i,      incrigaps,        {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_i,      incrigaps,        {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_o,      incrogaps,        {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_o,      incrogaps,        {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_6,      incrihgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_6,      incrihgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_7,      incrivgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_7,      incrivgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_8,      incrohgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_8,      incrohgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_9,      incrovgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_9,      incrovgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_0,      togglegaps,       {0} }, 
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_0,      defaultgaps,      {0} },
+	{ MODKEY,                       XK_Tab,    view,             {0} },
+	{ MODKEY|ControlMask,           XK_Right,  shiftviewclients, { .i = +1 } },
+	{ MODKEY|ControlMask,           XK_Left,   shiftviewclients, { .i = -1 } },
+	{ MODKEY|ShiftMask,             XK_a,      killclient,       {0} },
+	{ MODKEY,                       XK_t,      setlayout,        {.v = &layouts[0]} },
+	{ MODKEY,			XK_g,	   setlayout,	     {.v = &layouts[11]} },
+	{ MODKEY,                       XK_f,      setlayout,        {.v = &layouts[1]} },
+	{ MODKEY,                       XK_m,      setlayout,        {.v = &layouts[2]} },
+	{ MODKEY,                       XK_r,      setlayout,        {.v = &layouts[7]} },
+	{ MODKEY,                       XK_space,  setlayout,        {0} },
+	{ MODKEY|ShiftMask,             XK_space,  togglefloating,   {0} },
+	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,    {0} },
+	{ MODKEY,                       XK_0,      view,             {.ui = ~0 } },
+	{ MODKEY|ShiftMask,             XK_0,      tag,              {.ui = ~0 } },
+	{ MODKEY,                       XK_Left,   focusmon,         {.i = -1 } },
+	{ MODKEY,                       XK_Right,  focusmon,         {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_Left,   tagmon,           {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_Right,  tagmon,           {.i = +1 } },
+	TAGKEYS(                        XK_ampersand,                0)
+	TAGKEYS(                        XK_eacute,                   1)
+	TAGKEYS(                        XK_quotedbl,                 2)
+	TAGKEYS(                        XK_apostrophe,               3)
+	TAGKEYS(                        XK_parenleft,                4)
+	TAGKEYS(                        XK_minus,                    5)
+	TAGKEYS(                        XK_egrave,                   6)
+	TAGKEYS(                        XK_underscore,               7)
+	TAGKEYS(                        XK_ccedilla,                 8)
+	{ MODKEY|ShiftMask,             XK_e,      quit,             {0} },
+	{ MODKEY|ControlMask|ShiftMask, XK_e,      quit,             {1} },
+	{ 0, XF86XK_MonBrightnessDown,  	   spawn,	     SHCMD("thinkpad-backlight down ; kill -39 $(pidof dwmblocks)") },
+	{ 0, XF86XK_MonBrightnessUp,    	   spawn,	     SHCMD("thinkpad-backlight up ; kill -39 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioRaiseVolume,   	   spawn,	     SHCMD("setvolume up ; kill -45 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioLowerVolume,   	   spawn,	     SHCMD("setvolume down ; kill -45 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioMute,   	   	   spawn,	     SHCMD("pactl set-sink-mute 0 toggle ; kill -45 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioMicMute,       	   spawn,	     SHCMD("pactl set-source-mute 1 toggle") },
+	{ 0, XK_Caps_Lock,		   	   spawn,	     SHCMD("kill -40 $(pidof dwmblocks)") },
+	{ 0, XK_Print,		   		   spawn,	     SHCMD("scrot -e 'mv $f ~/Images/Screenshots' && sleep 2 && notify-send Screenshot!!!") },
+	{ MODKEY|ShiftMask,		XK_b,	   spawn,	     SHCMD("firefox") },			
+	{ MODKEY|ShiftMask,		XK_n,	   spawn,	     SHCMD("start-ncmpcpp") },			
 };
 
 /* button definitions */
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.h" ./config.h
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.h"	1970-01-01 01:00:00.000000000 +0100
+++ ./config.h	2021-01-15 01:47:47.198187672 +0100
@@ -0,0 +1,178 @@
+/* See LICENSE file for copyright and license details. */
+
+/* appearance */
+static const unsigned int borderpx  = 1;        /* border pixel of windows */
+static const unsigned int snap      = 32;       /* snap pixel */
+static const int swallowfloating    = 1;        /* 1 means swallow floating windows by default */
+static const unsigned int gappih    = 30;       /* horiz inner gap between windows */
+static const unsigned int gappiv    = 30;       /* vert inner gap between windows */
+static const unsigned int gappoh    = 30;       /* horiz outer gap between windows and screen edge */
+static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
+static       int smartgaps          = 1;        /* 1 means no outer gap when there is only one window */
+static const int showbar            = 1;        /* 0 means no bar */
+static const int topbar             = 0;        /* 0 means bottom bar */
+static const int user_bh            = 32;        /* 0 means that dwm will calculate bar height, >= 1 means dwm will user_bh as bar height */
+static const char *fonts[]          = { "MesloLGS Nerd Font:size=10" };
+static const char dmenufont[]       = "MesloLGS Nerd Font:size=10";
+
+#include "/home/fuzzbox/.cache/wal/colors-wal-dwm.h"
+
+/* tagging */
+static const char *tags[] = { "1 ", "2 ", "3 ", "4 ", "5 ", "6 ", "7 ", "8 ", "9 " };
+/* static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }; */
+
+static const Rule rules[] = {
+	/* xprop(1):
+	 *	WM_CLASS(STRING) = instance, class
+	 *	WM_NAME(STRING) = title
+	 */
+	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
+	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
+	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
+	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
+	{ "URxvt",   NULL,     NULL,	       0,	  0,	      1,	   0,	     -1 },
+	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+};
+
+/* layout(s) */
+static const float mfact     = 0.5; /* factor of master area size [0.05..0.95] */
+static const int nmaster     = 1;    /* number of clients in master area */
+static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
+static const int attachdirection = 0;    /* 0 default, 1 above, 2 aside, 3 below, 4 bottom, 5 top */
+
+
+#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
+
+#include "vanitygaps.c"
+
+static const Layout layouts[] = {
+	/* symbol     arrange function */
+	{ "[]=",      tile },    /* first entry is default */
+	{ "[M]",      monocle },
+	{ "[@]",      spiral },
+	{ "[\\]",     dwindle },
+	{ "H[]",      deck },
+	{ "TTT",      bstack },
+	{ "===",      bstackhoriz },
+	{ "HHH",      grid },
+	{ "###",      nrowgrid },
+	{ "---",      horizgrid },
+	{ ":::",      gaplessgrid },
+	{ "|M|",      centeredmaster },
+	{ ">M>",      centeredfloatingmaster },
+	{ "><>",      NULL },    /* no layout function means floating behavior */
+	{ NULL,       NULL },
+};
+
+/* key definitions */
+#define MODKEY Mod4Mask
+#define TAGKEYS(KEY,TAG) \
+	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+
+#include <X11/XF86keysym.h>
+
+/* helper for spawning shell commands in the pre dwm-5.0 fashion */
+#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+
+/* commands */
+static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+static const char *dmenucmd[]   = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-z", "800", "-p", "Run", NULL };
+static const char *dmenuwdcmd[] = { "dmenu-show-opened-windows", NULL };
+static const char *dmenucpcmd[] = { "clipmenu", "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-p", "Copy", NULL };
+static const char *dmenustcmd[] = { "dmenu-stop", NULL };
+static const char *termcmd[]    = { "urxvt", NULL };
+
+static Key keys[] = {
+	/* modifier                     key        function          argument */
+	{ MODKEY,                       XK_d,      spawn,            {.v = dmenucmd } },
+	{ MODKEY,			XK_w,	   spawn, 	     {.v = dmenuwdcmd } },
+	{ MODKEY,			XK_c,	   spawn,	     {.v = dmenucpcmd } },
+	{ MODKEY,	                XK_Return, spawn,            {.v = termcmd } },
+	{ MODKEY|ShiftMask,		XK_h,	   spawn,	     {.v = dmenustcmd } },
+	{ MODKEY,                       XK_b,      togglebar,        {0} },
+	{ MODKEY,                       XK_k, 	   focusstack,       {.i = +1 } },
+	{ MODKEY,                       XK_j,      focusstack,       {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_k,      pushdown,         {0} },
+	{ MODKEY|ShiftMask,             XK_j,      pushup,           {0} },
+	{ MODKEY,                       XK_i,      incnmaster,       {.i = +1 } },
+	{ MODKEY,                       XK_o,      incnmaster,       {.i = -1 } },
+	{ MODKEY,                       XK_h,      setmfact,         {.f = -0.05} },
+	{ MODKEY,                       XK_l,      setmfact,         {.f = +0.05} },
+	{ MODKEY|ShiftMask,             XK_Return, zoom,             {0} },
+	{ MODKEY|Mod1Mask,              XK_u,      incrgaps,         {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_u,      incrgaps,         {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_i,      incrigaps,        {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_i,      incrigaps,        {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_o,      incrogaps,        {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_o,      incrogaps,        {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_6,      incrihgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_6,      incrihgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_7,      incrivgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_7,      incrivgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_8,      incrohgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_8,      incrohgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_9,      incrovgaps,       {.i = +1 } },
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_9,      incrovgaps,       {.i = -1 } },
+	{ MODKEY|Mod1Mask,              XK_0,      togglegaps,       {0} }, 
+	{ MODKEY|Mod1Mask|ShiftMask,    XK_0,      defaultgaps,      {0} },
+	{ MODKEY,                       XK_Tab,    view,             {0} },
+	{ MODKEY|ControlMask,           XK_Right,  shiftviewclients, { .i = +1 } },
+	{ MODKEY|ControlMask,           XK_Left,   shiftviewclients, { .i = -1 } },
+	{ MODKEY|ShiftMask,             XK_a,      killclient,       {0} },
+	{ MODKEY,                       XK_t,      setlayout,        {.v = &layouts[0]} },
+	{ MODKEY,			XK_g,	   setlayout,	     {.v = &layouts[11]} },
+	{ MODKEY,                       XK_f,      setlayout,        {.v = &layouts[1]} },
+	{ MODKEY,                       XK_m,      setlayout,        {.v = &layouts[2]} },
+	{ MODKEY,                       XK_r,      setlayout,        {.v = &layouts[7]} },
+	{ MODKEY,                       XK_space,  setlayout,        {0} },
+	{ MODKEY|ShiftMask,             XK_space,  togglefloating,   {0} },
+	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,    {0} },
+	{ MODKEY,                       XK_0,      view,             {.ui = ~0 } },
+	{ MODKEY|ShiftMask,             XK_0,      tag,              {.ui = ~0 } },
+	{ MODKEY,                       XK_Left,   focusmon,         {.i = -1 } },
+	{ MODKEY,                       XK_Right,  focusmon,         {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_Left,   tagmon,           {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_Right,  tagmon,           {.i = +1 } },
+	TAGKEYS(                        XK_ampersand,                0)
+	TAGKEYS(                        XK_eacute,                   1)
+	TAGKEYS(                        XK_quotedbl,                 2)
+	TAGKEYS(                        XK_apostrophe,               3)
+	TAGKEYS(                        XK_parenleft,                4)
+	TAGKEYS(                        XK_minus,                    5)
+	TAGKEYS(                        XK_egrave,                   6)
+	TAGKEYS(                        XK_underscore,               7)
+	TAGKEYS(                        XK_ccedilla,                 8)
+	{ MODKEY|ShiftMask,             XK_e,      quit,             {0} },
+	{ MODKEY|ControlMask|ShiftMask, XK_e,      quit,             {1} },
+	{ 0, XF86XK_MonBrightnessDown,  	   spawn,	     SHCMD("thinkpad-backlight down ; kill -39 $(pidof dwmblocks)") },
+	{ 0, XF86XK_MonBrightnessUp,    	   spawn,	     SHCMD("thinkpad-backlight up ; kill -39 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioRaiseVolume,   	   spawn,	     SHCMD("setvolume up ; kill -45 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioLowerVolume,   	   spawn,	     SHCMD("setvolume down ; kill -45 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioMute,   	   	   spawn,	     SHCMD("pactl set-sink-mute 0 toggle ; kill -45 $(pidof dwmblocks)") },
+	{ 0, XF86XK_AudioMicMute,       	   spawn,	     SHCMD("pactl set-source-mute 1 toggle") },
+	{ 0, XK_Caps_Lock,		   	   spawn,	     SHCMD("kill -40 $(pidof dwmblocks)") },
+	{ 0, XK_Print,		   		   spawn,	     SHCMD("scrot -e 'mv $f ~/Images/Screenshots' && sleep 2 && notify-send Screenshot!!!") },
+	{ MODKEY|ShiftMask,		XK_b,	   spawn,	     SHCMD("firefox") },			
+	{ MODKEY|ShiftMask,		XK_n,	   spawn,	     SHCMD("start-ncmpcpp") },			
+};
+
+/* button definitions */
+/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+static Button buttons[] = {
+	/* click                event mask      button          function        argument */
+	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+	{ ClkTagBar,            0,              Button1,        view,           {0} },
+	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+};
+
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.mk" ./config.mk
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.mk"	2021-01-13 22:22:32.377160109 +0100
+++ ./config.mk	2021-01-14 12:01:27.645385019 +0100
@@ -19,10 +19,11 @@ FREETYPELIBS = -lfontconfig -lXft
 FREETYPEINC = /usr/include/freetype2
 # OpenBSD (uncomment)
 #FREETYPEINC = ${X11INC}/freetype2
+#KVMLIB = -lkvm
 
 # includes and libs
 INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
 
 # flags
 CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
Les fichiers binaires /home/fuzzbox/Téléchargements/dwm/drw.o et ./drw.o sont différents
Les fichiers binaires /home/fuzzbox/Téléchargements/dwm/dwm et ./dwm sont différents
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.1" ./dwm.1
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.1"	2021-01-13 22:22:32.377160109 +0100
+++ ./dwm.1	2021-01-14 12:01:27.645385019 +0100
@@ -30,6 +30,14 @@ top left corner.  The tags which are app
 indicated with an empty square in the top left corner.
 .P
 dwm draws a small border around windows to indicate the focus state.
+.P
+On start, dwm can start additional programs that may be specified in two special
+shell scripts (see the FILES section below), autostart_blocking.sh and
+autostart.sh.  The former is executed first and dwm will wait for its
+termination before starting.  The latter is executed in the background before
+dwm enters its handler loop.
+.P
+Either of these files may be omitted.
 .SH OPTIONS
 .TP
 .B \-v
@@ -142,6 +150,9 @@ Add/remove all windows with nth tag to/f
 .TP
 .B Mod1\-Shift\-q
 Quit dwm.
+.TP
+.B Mod1\-Control\-Shift\-q
+Restart dwm.
 .SS Mouse commands
 .TP
 .B Mod1\-Button1
@@ -152,9 +163,31 @@ Toggles focused window between floating
 .TP
 .B Mod1\-Button3
 Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+.SH FILES
+The files containing programs to be started along with dwm are searched for in
+the following directories:
+.IP "1. $XDG_DATA_HOME/dwm"
+.IP "2. $HOME/.local/share/dwm"
+.IP "3. $HOME/.dwm"
+.P
+The first existing directory is scanned for any of the autostart files below.
+.TP 15
+autostart.sh
+This file is started as a shell background process before dwm enters its handler
+loop.
+.TP 15
+autostart_blocking.sh
+This file is started before any autostart.sh; dwm waits for its termination.
 .SH CUSTOMIZATION
 dwm is customized by creating a custom config.h and (re)compiling the source
 code. This keeps it fast, secure and simple.
+.SH SIGNALS
+.TP
+.B SIGHUP - 1
+Restart the dwm process.
+.TP
+.B SIGTERM - 15
+Cleanly terminate the dwm process.
 .SH SEE ALSO
 .BR dmenu (1),
 .BR st (1)
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c" ./dwm.c
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c"	2021-01-13 22:22:32.380493442 +0100
+++ ./dwm.c	2021-01-15 01:47:32.278188444 +0100
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
@@ -40,6 +41,12 @@
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
 #include <X11/Xft/Xft.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/res.h>
+#ifdef __OpenBSD__
+#include <sys/sysctl.h>
+#include <kvm.h>
+#endif /* __OpenBSD */
 
 #include "drw.h"
 #include "util.h"
@@ -49,7 +56,8 @@
 #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
 #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
+#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
 #define LENGTH(X)               (sizeof X / sizeof X[0])
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
@@ -59,7 +67,7 @@
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
-enum { SchemeNorm, SchemeSel }; /* color schemes */
+enum { SchemeNorm, SchemeSel, SchemeUrg }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
@@ -92,9 +100,11 @@ struct Client {
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
 	int bw, oldbw;
 	unsigned int tags;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
+	pid_t pid;
 	Client *next;
 	Client *snext;
+	Client *swallowing;
 	Monitor *mon;
 	Window win;
 };
@@ -111,6 +121,7 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct Pertag Pertag;
 struct Monitor {
 	char ltsymbol[16];
 	float mfact;
@@ -119,6 +130,10 @@ struct Monitor {
 	int by;               /* bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
@@ -130,6 +145,7 @@ struct Monitor {
 	Monitor *next;
 	Window barwin;
 	const Layout *lt[2];
+	Pertag *pertag;
 };
 
 typedef struct {
@@ -138,6 +154,8 @@ typedef struct {
 	const char *title;
 	unsigned int tags;
 	int isfloating;
+	int isterminal;
+	int noswallow;
 	int monitor;
 } Rule;
 
@@ -147,6 +165,11 @@ static int applysizehints(Client *c, int
 static void arrange(Monitor *m);
 static void arrangemon(Monitor *m);
 static void attach(Client *c);
+static void attachabove(Client *c);
+static void attachaside(Client *c);
+static void attachbelow(Client *c);
+static void attachbottom(Client *c);
+static void attachtop(Client *c);
 static void attachstack(Client *c);
 static void buttonpress(XEvent *e);
 static void checkotherwm(void);
@@ -163,6 +186,7 @@ static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
+static int drawstatusbar(Monitor *m, int bh, char* text);
 static void enternotify(XEvent *e);
 static void expose(XEvent *e);
 static void focus(Client *c);
@@ -184,9 +208,13 @@ static void maprequest(XEvent *e);
 static void monocle(Monitor *m);
 static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
+static Client *nexttagged(Client *c);
 static Client *nexttiled(Client *c);
 static void pop(Client *);
+static Client *prevtiled(Client *c);
 static void propertynotify(XEvent *e);
+static void pushdown(const Arg *arg);
+static void pushup(const Arg *arg);
 static void quit(const Arg *arg);
 static Monitor *recttomon(int x, int y, int w, int h);
 static void resize(Client *c, int x, int y, int w, int h, int interact);
@@ -194,6 +222,7 @@ static void resizeclient(Client *c, int
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
+static void runautostart(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
 static void sendmon(Client *c, Monitor *m);
@@ -204,14 +233,17 @@ static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
+static void shiftviewclients(const Arg *arg);
 static void showhide(Client *c);
 static void sigchld(int unused);
+static void sighup(int unused);
+static void sigterm(int unused);
 static void spawn(const Arg *arg);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
-static void tile(Monitor *);
 static void togglebar(const Arg *arg);
 static void togglefloating(const Arg *arg);
+static void togglefullscr(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unfocus(Client *c, int setfocus);
@@ -235,9 +267,19 @@ static int xerrordummy(Display *dpy, XEr
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
 
+static pid_t getparentprocess(pid_t p);
+static int isdescprocess(pid_t p, pid_t c);
+static Client *swallowingclient(Window w);
+static Client *termforwin(const Client *c);
+static pid_t winpid(Window w);
+
 /* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
-static char stext[256];
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
+static char stext[1024];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh, blw = 0;      /* bar geometry */
@@ -261,6 +303,7 @@ static void (*handler[LASTEvent]) (XEven
 	[UnmapNotify] = unmapnotify
 };
 static Atom wmatom[WMLast], netatom[NetLast];
+static int restart = 0;
 static int running = 1;
 static Cur *cursor[CurLast];
 static Clr **scheme;
@@ -269,9 +312,20 @@ static Drw *drw;
 static Monitor *mons, *selmon;
 static Window root, wmcheckwin;
 
+static xcb_connection_t *xcon;
+
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
+struct Pertag {
+	unsigned int curtag, prevtag; /* current and previous tag */
+	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+};
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -298,6 +352,8 @@ applyrules(Client *c)
 		&& (!r->class || strstr(class, r->class))
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
+			c->isterminal = r->isterminal;
+			c->noswallow  = r->noswallow;
 			c->isfloating = r->isfloating;
 			c->tags |= r->tags;
 			for (m = mons; m && m->num != r->monitor; m = m->next);
@@ -408,6 +464,73 @@ attach(Client *c)
 }
 
 void
+attachabove(Client *c)
+{
+	if (c->mon->sel == NULL || c->mon->sel == c->mon->clients || c->mon->sel->isfloating) {
+		attach(c);
+		return;
+	}
+
+	Client *at;
+	for (at = c->mon->clients; at->next != c->mon->sel; at = at->next);
+	c->next = at->next;
+	at->next = c;
+}
+
+void
+attachaside(Client *c) {
+	Client *at = nexttagged(c);
+	if(!at) {
+		attach(c);
+		return;
+		}
+	c->next = at->next;
+	at->next = c;
+}
+
+void
+attachbelow(Client *c)
+{
+	if(c->mon->sel == NULL || c->mon->sel == c || c->mon->sel->isfloating) {
+		attach(c);
+		return;
+	}
+	c->next = c->mon->sel->next;
+	c->mon->sel->next = c;
+}
+ 
+void
+attachbottom(Client *c)
+{
+	Client *below = c->mon->clients;
+	for (; below && below->next; below = below->next);
+	c->next = NULL;
+	if (below)
+		below->next = c;
+	else
+		c->mon->clients = c;
+}
+
+void
+attachtop(Client *c)
+{
+	int n;
+	Monitor *m = selmon;
+	Client *below;
+
+	for (n = 1, below = c->mon->clients;
+		below && below->next && (below->isfloating || !ISVISIBLEONTAG(below, c->tags) || n != m->nmaster);
+		n = below->isfloating || !ISVISIBLEONTAG(below, c->tags) ? n + 0 : n + 1, below = below->next);
+	c->next = NULL;
+	if (below) {
+		c->next = below->next;
+		below->next = c;
+	}
+	else
+		c->mon->clients = c;
+}
+
+void
 attachstack(Client *c)
 {
 	c->snext = c->mon->stack;
@@ -415,6 +538,53 @@ attachstack(Client *c)
 }
 
 void
+swallow(Client *p, Client *c)
+{
+
+	if (c->noswallow || c->isterminal)
+		return;
+	if (c->noswallow && !swallowfloating && c->isfloating)
+		return;
+
+	detach(c);
+	detachstack(c);
+
+	setclientstate(c, WithdrawnState);
+	XUnmapWindow(dpy, p->win);
+
+	p->swallowing = c;
+	c->mon = p->mon;
+
+	Window w = p->win;
+	p->win = c->win;
+	c->win = w;
+	updatetitle(p);
+	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+	arrange(p->mon);
+	configure(p);
+	updateclientlist();
+}
+
+void
+unswallow(Client *c)
+{
+	c->win = c->swallowing->win;
+
+	free(c->swallowing);
+	c->swallowing = NULL;
+
+	/* unfullscreen the client */
+	setfullscreen(c, 0);
+	updatetitle(c);
+	arrange(c->mon);
+	XMapWindow(dpy, c->win);
+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+	setclientstate(c, NormalState);
+	focus(NULL);
+	arrange(c->mon);
+}
+
+void
 buttonpress(XEvent *e)
 {
 	unsigned int i, x, click;
@@ -485,7 +655,7 @@ cleanup(void)
 		cleanupmon(mons);
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < LENGTH(colors); i++)
+	for (i = 0; i < LENGTH(colors) + 1; i++)
 		free(scheme[i]);
 	XDestroyWindow(dpy, wmcheckwin);
 	drw_free(drw);
@@ -515,6 +685,7 @@ clientmessage(XEvent *e)
 {
 	XClientMessageEvent *cme = &e->xclient;
 	Client *c = wintoclient(cme->window);
+	unsigned int i;
 
 	if (!c)
 		return;
@@ -524,8 +695,14 @@ clientmessage(XEvent *e)
 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
-		if (c != selmon->sel && !c->isurgent)
-			seturgent(c, 1);
+		for (i = 0; i < LENGTH(tags) && !((1 << i) & c->tags); i++);
+		if (i < LENGTH(tags)) {
+			const Arg a = {.ui = 1 << i};
+			selmon = c->mon;
+			view(&a);
+			focus(c);
+			restack(selmon);
+		}
 	}
 }
 
@@ -632,6 +809,7 @@ Monitor *
 createmon(void)
 {
 	Monitor *m;
+	unsigned int i;
 
 	m = ecalloc(1, sizeof(Monitor));
 	m->tagset[0] = m->tagset[1] = 1;
@@ -639,9 +817,27 @@ createmon(void)
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+	m->pertag = ecalloc(1, sizeof(Pertag));
+	m->pertag->curtag = m->pertag->prevtag = 1;
+
+	for (i = 0; i <= LENGTH(tags); i++) {
+		m->pertag->nmasters[i] = m->nmaster;
+		m->pertag->mfacts[i] = m->mfact;
+
+		m->pertag->ltidxs[i][0] = m->lt[0];
+		m->pertag->ltidxs[i][1] = m->lt[1];
+		m->pertag->sellts[i] = m->sellt;
+
+		m->pertag->showbars[i] = m->showbar;
+	}
+
 	return m;
 }
 
@@ -653,6 +849,9 @@ destroynotify(XEvent *e)
 
 	if ((c = wintoclient(ev->window)))
 		unmanage(c, 1);
+
+	else if ((c = swallowingclient(ev->window)))
+		unmanage(c->swallowing, 1);
 }
 
 void
@@ -693,6 +892,114 @@ dirtomon(int dir)
 	return m;
 }
 
+int
+drawstatusbar(Monitor *m, int bh, char* stext) {
+	int ret, i, w, x, len;
+	short isCode = 0;
+	char *text;
+	char *p;
+
+	len = strlen(stext) + 1 ;
+	if (!(text = (char*) malloc(sizeof(char)*len)))
+		die("malloc");
+	p = text;
+	memcpy(text, stext, len);
+
+	/* compute width of the status text */
+	w = 0;
+	i = -1;
+	while (text[++i]) {
+		if (text[i] == '^') {
+			if (!isCode) {
+				isCode = 1;
+				text[i] = '\0';
+				w += TEXTW(text) - lrpad;
+				text[i] = '^';
+				if (text[++i] == 'f')
+					w += atoi(text + ++i);
+			} else {
+				isCode = 0;
+				text = text + i + 1;
+				i = -1;
+			}
+		}
+	}
+	if (!isCode)
+		w += TEXTW(text) - lrpad;
+	else
+		isCode = 0;
+	text = p;
+
+	w += 2; /* 1px padding on both sides */
+	ret = x = m->ww - w;
+
+	drw_setscheme(drw, scheme[LENGTH(colors)]);
+	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+	drw_rect(drw, x, 0, w, bh, 1, 1);
+	x++;
+
+	/* process status text */
+	i = -1;
+	while (text[++i]) {
+		if (text[i] == '^' && !isCode) {
+			isCode = 1;
+
+			text[i] = '\0';
+			w = TEXTW(text) - lrpad;
+			drw_text(drw, x, 0, w, bh, 0, text, 0);
+
+			x += w;
+
+			/* process code */
+			while (text[++i] != '^') {
+				if (text[i] == 'c') {
+					char buf[8];
+					memcpy(buf, (char*)text+i+1, 7);
+					buf[7] = '\0';
+					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+					i += 7;
+				} else if (text[i] == 'b') {
+					char buf[8];
+					memcpy(buf, (char*)text+i+1, 7);
+					buf[7] = '\0';
+					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+					i += 7;
+				} else if (text[i] == 'd') {
+					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+				} else if (text[i] == 'r') {
+					int rx = atoi(text + ++i);
+					while (text[++i] != ',');
+					int ry = atoi(text + ++i);
+					while (text[++i] != ',');
+					int rw = atoi(text + ++i);
+					while (text[++i] != ',');
+					int rh = atoi(text + ++i);
+
+					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+				} else if (text[i] == 'f') {
+					x += atoi(text + ++i);
+				}
+			}
+
+			text = text + i + 1;
+			i=-1;
+			isCode = 0;
+		}
+	}
+
+	if (!isCode) {
+		w = TEXTW(text) - lrpad;
+		drw_text(drw, x, 0, w, bh, 0, text, 0);
+	}
+
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	free(p);
+
+	return ret;
+}
+
 void
 drawbar(Monitor *m)
 {
@@ -704,9 +1011,7 @@ drawbar(Monitor *m)
 
 	/* draw status first so it can be overdrawn by tags later */
 	if (m == selmon) { /* status is only drawn on selected monitor */
-		drw_setscheme(drw, scheme[SchemeNorm]);
-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+		tw = m->ww - drawstatusbar(m, bh, stext);
 	}
 
 	for (c = m->clients; c; c = c->next) {
@@ -967,7 +1272,7 @@ grabkeys(void)
 void
 incnmaster(const Arg *arg)
 {
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
 	arrange(selmon);
 }
 
@@ -1018,12 +1323,13 @@ killclient(const Arg *arg)
 void
 manage(Window w, XWindowAttributes *wa)
 {
-	Client *c, *t = NULL;
+	Client *c, *t = NULL, *term = NULL;
 	Window trans = None;
 	XWindowChanges wc;
 
 	c = ecalloc(1, sizeof(Client));
 	c->win = w;
+	c->pid = winpid(w);
 	/* geometry */
 	c->x = c->oldx = wa->x;
 	c->y = c->oldy = wa->y;
@@ -1038,6 +1344,7 @@ manage(Window w, XWindowAttributes *wa)
 	} else {
 		c->mon = selmon;
 		applyrules(c);
+		term = termforwin(c);
 	}
 
 	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
@@ -1063,7 +1370,25 @@ manage(Window w, XWindowAttributes *wa)
 		c->isfloating = c->oldstate = trans != None || c->isfixed;
 	if (c->isfloating)
 		XRaiseWindow(dpy, c->win);
-	attach(c);
+	switch(attachdirection){
+		case 1:
+			attachabove(c);
+			break;
+		case 2:
+			attachaside(c);
+			break;
+		case 3:
+			attachbelow(c);
+			break;
+		case 4:
+			attachbottom(c);
+			break;
+		case 5:
+			attachtop(c);
+			break;
+		default:
+			attach(c);
+	}
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
 		(unsigned char *) &(c->win), 1);
@@ -1074,6 +1399,8 @@ manage(Window w, XWindowAttributes *wa)
 	c->mon->sel = c;
 	arrange(c->mon);
 	XMapWindow(dpy, c->win);
+	if (term)
+		swallow(term, c);
 	focus(NULL);
 }
 
@@ -1194,6 +1521,16 @@ movemouse(const Arg *arg)
 }
 
 Client *
+nexttagged(Client *c) {
+	Client *walked = c->mon->clients;
+	for(;
+		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
+		walked = walked->next
+	);
+	return walked;
+}
+
+Client *
 nexttiled(Client *c)
 {
 	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
@@ -1209,6 +1546,16 @@ pop(Client *c)
 	arrange(c->mon);
 }
 
+Client *
+prevtiled(Client *c) {
+	Client *p, *r;
+
+	for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
+		if(!p->isfloating && ISVISIBLE(p))
+			r = p;
+	return r;
+}
+
 void
 propertynotify(XEvent *e)
 {
@@ -1247,8 +1594,40 @@ propertynotify(XEvent *e)
 }
 
 void
+pushdown(const Arg *arg) {
+	Client *sel = selmon->sel, *c;
+
+	if(!sel || sel->isfloating || sel == nexttiled(selmon->clients))
+		return;
+	if((c = nexttiled(sel->next))) {
+		detach(sel);
+		sel->next = c->next;
+		c->next = sel;
+	}
+	focus(sel);
+	arrange(selmon);
+}
+
+void
+pushup(const Arg *arg) {
+	Client *sel = selmon->sel, *c;
+
+	if(!sel || sel->isfloating)
+		return;
+	if((c = prevtiled(sel)) && c != nexttiled(selmon->clients)) {
+		detach(sel);
+		sel->next = c;
+		for(c = selmon->clients; c->next != sel->next; c = c->next);
+		c->next = sel;
+	}
+	focus(sel);
+	arrange(selmon);
+}
+
+void
 quit(const Arg *arg)
 {
+	if(arg->i) restart = 1;
 	running = 0;
 }
 
@@ -1283,6 +1662,14 @@ resizeclient(Client *c, int x, int y, in
 	c->oldw = c->w; c->w = wc.width = w;
 	c->oldh = c->h; c->h = wc.height = h;
 	wc.border_width = c->bw;
+	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+	    && !c->isfullscreen && !c->isfloating
+	    && NULL != c->mon->lt[c->mon->sellt]->arrange) {
+		c->w = wc.width += c->bw * 2;
+		c->h = wc.height += c->bw * 2;
+		wc.border_width = 0;
+	}
 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
 	configure(c);
 	XSync(dpy, False);
@@ -1382,6 +1769,83 @@ run(void)
 }
 
 void
+runautostart(void)
+{
+	char *pathpfx;
+	char *path;
+	char *xdgdatahome;
+	char *home;
+	struct stat sb;
+
+	if ((home = getenv("HOME")) == NULL)
+		/* this is almost impossible */
+		return;
+
+	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+	 * otherwise use ~/.local/share/dwm as autostart script directory
+	 */
+	xdgdatahome = getenv("XDG_DATA_HOME");
+	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+		/* space for path segments, separators and nul */
+		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+
+		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	} else {
+		/* space for path segments, separators and nul */
+		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+		                     + strlen(dwmdir) + 3);
+
+		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* check if the autostart script directory exists */
+	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+		/* the XDG conformant path does not exist or is no directory
+		 * so we try ~/.dwm instead
+		 */
+		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+		if(pathpfx_new == NULL) {
+			free(pathpfx);
+			return;
+		}
+   pathpfx = pathpfx_new;
+
+		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* try the blocking script first */
+	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(path);
+
+	/* now the non-blocking script */
+	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(strcat(path, " &"));
+
+	free(pathpfx);
+	free(path);
+}
+
+void
 scan(void)
 {
 	unsigned int i, num;
@@ -1418,7 +1882,25 @@ sendmon(Client *c, Monitor *m)
 	detachstack(c);
 	c->mon = m;
 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-	attach(c);
+	switch(attachdirection){
+		case 1:
+			attachabove(c);
+			break;
+		case 2:
+			attachaside(c);
+			break;
+		case 3:
+			attachbelow(c);
+			break;
+		case 4:
+			attachbottom(c);
+			break;
+		case 5:
+			attachtop(c);
+			break;
+		default:
+			attach(c);
+	}
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
@@ -1502,9 +1984,9 @@ void
 setlayout(const Arg *arg)
 {
 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
 	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
 	if (selmon->sel)
 		arrange(selmon);
@@ -1523,7 +2005,7 @@ setmfact(const Arg *arg)
 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if (f < 0.05 || f > 0.95)
 		return;
-	selmon->mfact = f;
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
 	arrange(selmon);
 }
 
@@ -1537,6 +2019,9 @@ setup(void)
 	/* clean up any zombies immediately */
 	sigchld(0);
 
+	signal(SIGHUP, sighup);
+	signal(SIGTERM, sigterm);
+
 	/* init screen */
 	screen = DefaultScreen(dpy);
 	sw = DisplayWidth(dpy, screen);
@@ -1546,7 +2031,7 @@ setup(void)
 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
 		die("no fonts could be loaded.");
 	lrpad = drw->fonts->h;
-	bh = drw->fonts->h + 2;
+	bh = user_bh ? user_bh : drw->fonts->h + 2;
 	updategeom();
 	/* init atoms */
 	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
@@ -1568,7 +2053,8 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
 	for (i = 0; i < LENGTH(colors); i++)
 		scheme[i] = drw_scm_create(drw, colors[i], 3);
 	/* init bars */
@@ -1612,6 +2098,46 @@ seturgent(Client *c, int urg)
 }
 
 void
+shiftviewclients(const Arg *arg)
+{
+	Arg shifted;
+	Client *c;
+	unsigned int tagmask = 0;
+
+	for (c = selmon->clients; c; c = c->next)
+		#if SCRATCHPADS_PATCH
+		if (!(c->tags & SPTAGMASK))
+			tagmask = tagmask | c->tags;
+		#else
+		tagmask = tagmask | c->tags;
+		#endif // SCRATCHPADS_PATCH
+
+	#if SCRATCHPADS_PATCH
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+	#else
+	shifted.ui = selmon->tagset[selmon->seltags];
+	#endif // SCRATCHPADS_PATCH
+	if (arg->i > 0) // left circular shift
+		do {
+			shifted.ui = (shifted.ui << arg->i)
+			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+			#if SCRATCHPADS_PATCH
+			shifted.ui &= ~SPTAGMASK;
+			#endif // SCRATCHPADS_PATCH
+		} while (tagmask && !(shifted.ui & tagmask));
+	else // right circular shift
+		do {
+			shifted.ui = (shifted.ui >> (- arg->i)
+			   | shifted.ui << (LENGTH(tags) + arg->i));
+			#if SCRATCHPADS_PATCH
+			shifted.ui &= ~SPTAGMASK;
+			#endif // SCRATCHPADS_PATCH
+		} while (tagmask && !(shifted.ui & tagmask));
+
+	view(&shifted);
+}
+
+void
 showhide(Client *c)
 {
 	if (!c)
@@ -1638,6 +2164,20 @@ sigchld(int unused)
 }
 
 void
+sighup(int unused)
+{
+	Arg a = {.i = 1};
+	quit(&a);
+}
+
+void
+sigterm(int unused)
+{
+	Arg a = {.i = 0};
+	quit(&a);
+}
+
+void
 spawn(const Arg *arg)
 {
 	if (arg->v == dmenucmd)
@@ -1672,37 +2212,9 @@ tagmon(const Arg *arg)
 }
 
 void
-tile(Monitor *m)
-{
-	unsigned int i, n, h, mw, my, ty;
-	Client *c;
-
-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-	if (n == 0)
-		return;
-
-	if (n > m->nmaster)
-		mw = m->nmaster ? m->ww * m->mfact : 0;
-	else
-		mw = m->ww;
-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-		if (i < m->nmaster) {
-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
-			if (my + HEIGHT(c) < m->wh)
-				my += HEIGHT(c);
-		} else {
-			h = (m->wh - ty) / (n - i);
-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
-			if (ty + HEIGHT(c) < m->wh)
-				ty += HEIGHT(c);
-		}
-}
-
-void
 togglebar(const Arg *arg)
 {
-	selmon->showbar = !selmon->showbar;
+	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
 	updatebarpos(selmon);
 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
 	arrange(selmon);
@@ -1723,6 +2235,13 @@ togglefloating(const Arg *arg)
 }
 
 void
+togglefullscr(const Arg *arg)
+{
+  if(selmon->sel)
+    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+}
+
+void
 toggletag(const Arg *arg)
 {
 	unsigned int newtags;
@@ -1741,9 +2260,33 @@ void
 toggleview(const Arg *arg)
 {
 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+	int i;
 
 	if (newtagset) {
 		selmon->tagset[selmon->seltags] = newtagset;
+
+		if (newtagset == ~0) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			selmon->pertag->curtag = 0;
+		}
+
+		/* test if the user did not select the same tag */
+		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			for (i = 0; !(newtagset & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+
+		/* apply settings for this view */
+		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
+		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+			togglebar(NULL);
+
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -1768,6 +2311,20 @@ unmanage(Client *c, int destroyed)
 	Monitor *m = c->mon;
 	XWindowChanges wc;
 
+	if (c->swallowing) {
+		unswallow(c);
+		return;
+	}
+
+	Client *s = swallowingclient(c->win);
+	if (s) {
+		free(s->swallowing);
+		s->swallowing = NULL;
+		arrange(m);
+		focus(NULL);
+		return;
+	}
+
 	detach(c);
 	detachstack(c);
 	if (!destroyed) {
@@ -1782,9 +2339,12 @@ unmanage(Client *c, int destroyed)
 		XUngrabServer(dpy);
 	}
 	free(c);
-	focus(NULL);
-	updateclientlist();
-	arrange(m);
+
+	if (!s) {
+		arrange(m);
+		focus(NULL);
+		updateclientlist();
+	}
 }
 
 void
@@ -1900,7 +2460,25 @@ updategeom(void)
 					m->clients = c->next;
 					detachstack(c);
 					c->mon = mons;
-					attach(c);
+					switch(attachdirection){
+					case 1:
+						attachabove(c);
+						break;
+					case 2:
+						attachaside(c);
+						break;
+					case 3:
+						attachbelow(c);
+						break;
+					case 4:
+						attachbottom(c);
+						break;
+					case 5:
+						attachtop(c);
+						break;
+					default:
+						attach(c);
+					}
 					attachstack(c);
 				}
 				if (m == selmon)
@@ -2025,8 +2603,11 @@ updatewmhints(Client *c)
 		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
 			wmh->flags &= ~XUrgencyHint;
 			XSetWMHints(dpy, c->win, wmh);
-		} else
+		} else {
 			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
+			if (c->isurgent)
+				XSetWindowBorder(dpy, c->win, scheme[SchemeUrg][ColBorder].pixel);
+		}
 		if (wmh->flags & InputHint)
 			c->neverfocus = !wmh->input;
 		else
@@ -2038,15 +2619,171 @@ updatewmhints(Client *c)
 void
 view(const Arg *arg)
 {
+	int i;
+	unsigned int tmptag;
+
 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
 	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
+	if (arg->ui & TAGMASK) {
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+
+		if (arg->ui == ~0)
+			selmon->pertag->curtag = 0;
+		else {
+			for (i = 0; !(arg->ui & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+	} else {
+		tmptag = selmon->pertag->prevtag;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+		selmon->pertag->curtag = tmptag;
+	}
+
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
+	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+		togglebar(NULL);
+
 	focus(NULL);
 	arrange(selmon);
 }
 
+pid_t
+winpid(Window w)
+{
+
+	pid_t result = 0;
+
+#ifdef __linux__
+	xcb_res_client_id_spec_t spec = {0};
+	spec.client = w;
+	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+
+	xcb_generic_error_t *e = NULL;
+	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+
+	if (!r)
+		return (pid_t)0;
+
+	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+		spec = i.data->spec;
+		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+			uint32_t *t = xcb_res_client_id_value_value(i.data);
+			result = *t;
+			break;
+		}
+	}
+
+	free(r);
+
+	if (result == (pid_t)-1)
+		result = 0;
+
+#endif /* __linux__ */
+
+#ifdef __OpenBSD__
+        Atom type;
+        int format;
+        unsigned long len, bytes;
+        unsigned char *prop;
+        pid_t ret;
+
+        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+               return 0;
+
+        ret = *(pid_t*)prop;
+        XFree(prop);
+        result = ret;
+
+#endif /* __OpenBSD__ */
+	return result;
+}
+
+pid_t
+getparentprocess(pid_t p)
+{
+	unsigned int v = 0;
+
+#ifdef __linux__
+	FILE *f;
+	char buf[256];
+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+
+	if (!(f = fopen(buf, "r")))
+		return 0;
+
+	fscanf(f, "%*u %*s %*c %u", &v);
+	fclose(f);
+#endif /* __linux__*/
+
+#ifdef __OpenBSD__
+	int n;
+	kvm_t *kd;
+	struct kinfo_proc *kp;
+
+	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+	if (!kd)
+		return 0;
+
+	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+	v = kp->p_ppid;
+#endif /* __OpenBSD__ */
+
+	return (pid_t)v;
+}
+
+int
+isdescprocess(pid_t p, pid_t c)
+{
+	while (p != c && c != 0)
+		c = getparentprocess(c);
+
+	return (int)c;
+}
+
+Client *
+termforwin(const Client *w)
+{
+	Client *c;
+	Monitor *m;
+
+	if (!w->pid || w->isterminal)
+		return NULL;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+				return c;
+		}
+	}
+
+	return NULL;
+}
+
+Client *
+swallowingclient(Window w)
+{
+	Client *c;
+	Monitor *m;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->swallowing && c->swallowing->win == w)
+				return c;
+		}
+	}
+
+	return NULL;
+}
+
 Client *
 wintoclient(Window w)
 {
@@ -2138,14 +2875,18 @@ main(int argc, char *argv[])
 		fputs("warning: no locale support\n", stderr);
 	if (!(dpy = XOpenDisplay(NULL)))
 		die("dwm: cannot open display");
+	if (!(xcon = XGetXCBConnection(dpy)))
+		die("dwm: cannot get xcb connection\n");
 	checkotherwm();
 	setup();
 #ifdef __OpenBSD__
-	if (pledge("stdio rpath proc exec", NULL) == -1)
+	if (pledge("stdio rpath proc exec ps", NULL) == -1)
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
+	runautostart();
 	run();
+	if(restart) execvp(argv[0], argv);
 	cleanup();
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c.orig" ./dwm.c.orig
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c.orig"	1970-01-01 01:00:00.000000000 +0100
+++ ./dwm.c.orig	2021-01-15 01:42:37.278203726 +0100
@@ -0,0 +1,2817 @@
+/* See LICENSE file for copyright and license details.
+ *
+ * dynamic window manager is designed like any other X client as well. It is
+ * driven through handling X events. In contrast to other X clients, a window
+ * manager selects for SubstructureRedirectMask on the root window, to receive
+ * events about window (dis-)appearance. Only one X connection at a time is
+ * allowed to select for this event mask.
+ *
+ * The event handlers of dwm are organized in an array which is accessed
+ * whenever a new event has been fetched. This allows event dispatching
+ * in O(1) time.
+ *
+ * Each child of the root window is called a client, except windows which have
+ * set the override_redirect flag. Clients are organized in a linked client
+ * list on each monitor, the focus history is remembered through a stack list
+ * on each monitor. Each client contains a bit array to indicate the tags of a
+ * client.
+ *
+ * Keys and tagging rules are organized as arrays and defined in config.h.
+ *
+ * To understand everything else, start reading main().
+ */
+#include <errno.h>
+#include <locale.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xproto.h>
+#include <X11/Xutil.h>
+#ifdef XINERAMA
+#include <X11/extensions/Xinerama.h>
+#endif /* XINERAMA */
+#include <X11/Xft/Xft.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/res.h>
+#ifdef __OpenBSD__
+#include <sys/sysctl.h>
+#include <kvm.h>
+#endif /* __OpenBSD */
+
+#include "drw.h"
+#include "util.h"
+
+/* macros */
+#define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+#define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+#define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
+#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
+#define LENGTH(X)               (sizeof X / sizeof X[0])
+#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+#define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+#define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+
+/* enums */
+enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+enum { SchemeNorm, SchemeSel, SchemeUrg }; /* color schemes */
+enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+
+typedef union {
+	int i;
+	unsigned int ui;
+	float f;
+	const void *v;
+} Arg;
+
+typedef struct {
+	unsigned int click;
+	unsigned int mask;
+	unsigned int button;
+	void (*func)(const Arg *arg);
+	const Arg arg;
+} Button;
+
+typedef struct Monitor Monitor;
+typedef struct Client Client;
+struct Client {
+	char name[256];
+	float mina, maxa;
+	int x, y, w, h;
+	int oldx, oldy, oldw, oldh;
+	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
+	int bw, oldbw;
+	unsigned int tags;
+	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
+	pid_t pid;
+	Client *next;
+	Client *snext;
+	Client *swallowing;
+	Monitor *mon;
+	Window win;
+};
+
+typedef struct {
+	unsigned int mod;
+	KeySym keysym;
+	void (*func)(const Arg *);
+	const Arg arg;
+} Key;
+
+typedef struct {
+	const char *symbol;
+	void (*arrange)(Monitor *);
+} Layout;
+
+struct Monitor {
+	char ltsymbol[16];
+	float mfact;
+	int nmaster;
+	int num;
+	int by;               /* bar geometry */
+	int mx, my, mw, mh;   /* screen size */
+	int wx, wy, ww, wh;   /* window area  */
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
+	unsigned int seltags;
+	unsigned int sellt;
+	unsigned int tagset[2];
+	int showbar;
+	int topbar;
+	Client *clients;
+	Client *sel;
+	Client *stack;
+	Monitor *next;
+	Window barwin;
+	const Layout *lt[2];
+};
+
+typedef struct {
+	const char *class;
+	const char *instance;
+	const char *title;
+	unsigned int tags;
+	int isfloating;
+	int isterminal;
+	int noswallow;
+	int monitor;
+} Rule;
+
+/* function declarations */
+static void applyrules(Client *c);
+static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+static void arrange(Monitor *m);
+static void arrangemon(Monitor *m);
+static void attach(Client *c);
+static void attachabove(Client *c);
+static void attachaside(Client *c);
+static void attachbelow(Client *c);
+static void attachbottom(Client *c);
+static void attachtop(Client *c);
+static void attachstack(Client *c);
+static void buttonpress(XEvent *e);
+static void checkotherwm(void);
+static void cleanup(void);
+static void cleanupmon(Monitor *mon);
+static void clientmessage(XEvent *e);
+static void configure(Client *c);
+static void configurenotify(XEvent *e);
+static void configurerequest(XEvent *e);
+static Monitor *createmon(void);
+static void destroynotify(XEvent *e);
+static void detach(Client *c);
+static void detachstack(Client *c);
+static Monitor *dirtomon(int dir);
+static void drawbar(Monitor *m);
+static void drawbars(void);
+static int drawstatusbar(Monitor *m, int bh, char* text);
+static void enternotify(XEvent *e);
+static void expose(XEvent *e);
+static void focus(Client *c);
+static void focusin(XEvent *e);
+static void focusmon(const Arg *arg);
+static void focusstack(const Arg *arg);
+static Atom getatomprop(Client *c, Atom prop);
+static int getrootptr(int *x, int *y);
+static long getstate(Window w);
+static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+static void grabbuttons(Client *c, int focused);
+static void grabkeys(void);
+static void incnmaster(const Arg *arg);
+static void keypress(XEvent *e);
+static void killclient(const Arg *arg);
+static void manage(Window w, XWindowAttributes *wa);
+static void mappingnotify(XEvent *e);
+static void maprequest(XEvent *e);
+static void monocle(Monitor *m);
+static void motionnotify(XEvent *e);
+static void movemouse(const Arg *arg);
+static Client *nexttagged(Client *c);
+static Client *nexttiled(Client *c);
+static void pop(Client *);
+static Client *prevtiled(Client *c);
+static void propertynotify(XEvent *e);
+static void pushdown(const Arg *arg);
+static void pushup(const Arg *arg);
+static void quit(const Arg *arg);
+static Monitor *recttomon(int x, int y, int w, int h);
+static void resize(Client *c, int x, int y, int w, int h, int interact);
+static void resizeclient(Client *c, int x, int y, int w, int h);
+static void resizemouse(const Arg *arg);
+static void restack(Monitor *m);
+static void run(void);
+static void runautostart(void);
+static void scan(void);
+static int sendevent(Client *c, Atom proto);
+static void sendmon(Client *c, Monitor *m);
+static void setclientstate(Client *c, long state);
+static void setfocus(Client *c);
+static void setfullscreen(Client *c, int fullscreen);
+static void setlayout(const Arg *arg);
+static void setmfact(const Arg *arg);
+static void setup(void);
+static void seturgent(Client *c, int urg);
+static void shiftviewclients(const Arg *arg);
+static void showhide(Client *c);
+static void sigchld(int unused);
+static void sighup(int unused);
+static void sigterm(int unused);
+static void spawn(const Arg *arg);
+static void tag(const Arg *arg);
+static void tagmon(const Arg *arg);
+static void togglebar(const Arg *arg);
+static void togglefloating(const Arg *arg);
+static void togglefullscr(const Arg *arg);
+static void toggletag(const Arg *arg);
+static void toggleview(const Arg *arg);
+static void unfocus(Client *c, int setfocus);
+static void unmanage(Client *c, int destroyed);
+static void unmapnotify(XEvent *e);
+static void updatebarpos(Monitor *m);
+static void updatebars(void);
+static void updateclientlist(void);
+static int updategeom(void);
+static void updatenumlockmask(void);
+static void updatesizehints(Client *c);
+static void updatestatus(void);
+static void updatetitle(Client *c);
+static void updatewindowtype(Client *c);
+static void updatewmhints(Client *c);
+static void view(const Arg *arg);
+static Client *wintoclient(Window w);
+static Monitor *wintomon(Window w);
+static int xerror(Display *dpy, XErrorEvent *ee);
+static int xerrordummy(Display *dpy, XErrorEvent *ee);
+static int xerrorstart(Display *dpy, XErrorEvent *ee);
+static void zoom(const Arg *arg);
+
+static pid_t getparentprocess(pid_t p);
+static int isdescprocess(pid_t p, pid_t c);
+static Client *swallowingclient(Window w);
+static Client *termforwin(const Client *c);
+static pid_t winpid(Window w);
+
+/* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
+static const char broken[] = "broken";
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
+static char stext[1024];
+static int screen;
+static int sw, sh;           /* X display screen geometry width, height */
+static int bh, blw = 0;      /* bar geometry */
+static int lrpad;            /* sum of left and right padding for text */
+static int (*xerrorxlib)(Display *, XErrorEvent *);
+static unsigned int numlockmask = 0;
+static void (*handler[LASTEvent]) (XEvent *) = {
+	[ButtonPress] = buttonpress,
+	[ClientMessage] = clientmessage,
+	[ConfigureRequest] = configurerequest,
+	[ConfigureNotify] = configurenotify,
+	[DestroyNotify] = destroynotify,
+	[EnterNotify] = enternotify,
+	[Expose] = expose,
+	[FocusIn] = focusin,
+	[KeyPress] = keypress,
+	[MappingNotify] = mappingnotify,
+	[MapRequest] = maprequest,
+	[MotionNotify] = motionnotify,
+	[PropertyNotify] = propertynotify,
+	[UnmapNotify] = unmapnotify
+};
+static Atom wmatom[WMLast], netatom[NetLast];
+static int restart = 0;
+static int running = 1;
+static Cur *cursor[CurLast];
+static Clr **scheme;
+static Display *dpy;
+static Drw *drw;
+static Monitor *mons, *selmon;
+static Window root, wmcheckwin;
+
+static xcb_connection_t *xcon;
+
+/* configuration, allows nested code to access above variables */
+#include "config.h"
+
+/* compile-time check if all tags fit into an unsigned int bit array. */
+struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+
+/* function implementations */
+void
+applyrules(Client *c)
+{
+	const char *class, *instance;
+	unsigned int i;
+	const Rule *r;
+	Monitor *m;
+	XClassHint ch = { NULL, NULL };
+
+	/* rule matching */
+	c->isfloating = 0;
+	c->tags = 0;
+	XGetClassHint(dpy, c->win, &ch);
+	class    = ch.res_class ? ch.res_class : broken;
+	instance = ch.res_name  ? ch.res_name  : broken;
+
+	for (i = 0; i < LENGTH(rules); i++) {
+		r = &rules[i];
+		if ((!r->title || strstr(c->name, r->title))
+		&& (!r->class || strstr(class, r->class))
+		&& (!r->instance || strstr(instance, r->instance)))
+		{
+			c->isterminal = r->isterminal;
+			c->noswallow  = r->noswallow;
+			c->isfloating = r->isfloating;
+			c->tags |= r->tags;
+			for (m = mons; m && m->num != r->monitor; m = m->next);
+			if (m)
+				c->mon = m;
+		}
+	}
+	if (ch.res_class)
+		XFree(ch.res_class);
+	if (ch.res_name)
+		XFree(ch.res_name);
+	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+}
+
+int
+applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
+{
+	int baseismin;
+	Monitor *m = c->mon;
+
+	/* set minimum possible */
+	*w = MAX(1, *w);
+	*h = MAX(1, *h);
+	if (interact) {
+		if (*x > sw)
+			*x = sw - WIDTH(c);
+		if (*y > sh)
+			*y = sh - HEIGHT(c);
+		if (*x + *w + 2 * c->bw < 0)
+			*x = 0;
+		if (*y + *h + 2 * c->bw < 0)
+			*y = 0;
+	} else {
+		if (*x >= m->wx + m->ww)
+			*x = m->wx + m->ww - WIDTH(c);
+		if (*y >= m->wy + m->wh)
+			*y = m->wy + m->wh - HEIGHT(c);
+		if (*x + *w + 2 * c->bw <= m->wx)
+			*x = m->wx;
+		if (*y + *h + 2 * c->bw <= m->wy)
+			*y = m->wy;
+	}
+	if (*h < bh)
+		*h = bh;
+	if (*w < bh)
+		*w = bh;
+	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
+		/* see last two sentences in ICCCM 4.1.2.3 */
+		baseismin = c->basew == c->minw && c->baseh == c->minh;
+		if (!baseismin) { /* temporarily remove base dimensions */
+			*w -= c->basew;
+			*h -= c->baseh;
+		}
+		/* adjust for aspect limits */
+		if (c->mina > 0 && c->maxa > 0) {
+			if (c->maxa < (float)*w / *h)
+				*w = *h * c->maxa + 0.5;
+			else if (c->mina < (float)*h / *w)
+				*h = *w * c->mina + 0.5;
+		}
+		if (baseismin) { /* increment calculation requires this */
+			*w -= c->basew;
+			*h -= c->baseh;
+		}
+		/* adjust for increment value */
+		if (c->incw)
+			*w -= *w % c->incw;
+		if (c->inch)
+			*h -= *h % c->inch;
+		/* restore base dimensions */
+		*w = MAX(*w + c->basew, c->minw);
+		*h = MAX(*h + c->baseh, c->minh);
+		if (c->maxw)
+			*w = MIN(*w, c->maxw);
+		if (c->maxh)
+			*h = MIN(*h, c->maxh);
+	}
+	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
+}
+
+void
+arrange(Monitor *m)
+{
+	if (m)
+		showhide(m->stack);
+	else for (m = mons; m; m = m->next)
+		showhide(m->stack);
+	if (m) {
+		arrangemon(m);
+		restack(m);
+	} else for (m = mons; m; m = m->next)
+		arrangemon(m);
+}
+
+void
+arrangemon(Monitor *m)
+{
+	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
+	if (m->lt[m->sellt]->arrange)
+		m->lt[m->sellt]->arrange(m);
+}
+
+void
+attach(Client *c)
+{
+	c->next = c->mon->clients;
+	c->mon->clients = c;
+}
+
+void
+attachabove(Client *c)
+{
+	if (c->mon->sel == NULL || c->mon->sel == c->mon->clients || c->mon->sel->isfloating) {
+		attach(c);
+		return;
+	}
+
+	Client *at;
+	for (at = c->mon->clients; at->next != c->mon->sel; at = at->next);
+	c->next = at->next;
+	at->next = c;
+}
+
+void
+attachaside(Client *c) {
+	Client *at = nexttagged(c);
+	if(!at) {
+		attach(c);
+		return;
+		}
+	c->next = at->next;
+	at->next = c;
+}
+
+void
+attachbelow(Client *c)
+{
+	if(c->mon->sel == NULL || c->mon->sel == c || c->mon->sel->isfloating) {
+		attach(c);
+		return;
+	}
+	c->next = c->mon->sel->next;
+	c->mon->sel->next = c;
+}
+ 
+void
+attachbottom(Client *c)
+{
+	Client *below = c->mon->clients;
+	for (; below && below->next; below = below->next);
+	c->next = NULL;
+	if (below)
+		below->next = c;
+	else
+		c->mon->clients = c;
+}
+
+void
+attachtop(Client *c)
+{
+	int n;
+	Monitor *m = selmon;
+	Client *below;
+
+	for (n = 1, below = c->mon->clients;
+		below && below->next && (below->isfloating || !ISVISIBLEONTAG(below, c->tags) || n != m->nmaster);
+		n = below->isfloating || !ISVISIBLEONTAG(below, c->tags) ? n + 0 : n + 1, below = below->next);
+	c->next = NULL;
+	if (below) {
+		c->next = below->next;
+		below->next = c;
+	}
+	else
+		c->mon->clients = c;
+}
+
+void
+attachstack(Client *c)
+{
+	c->snext = c->mon->stack;
+	c->mon->stack = c;
+}
+
+void
+swallow(Client *p, Client *c)
+{
+
+	if (c->noswallow || c->isterminal)
+		return;
+	if (c->noswallow && !swallowfloating && c->isfloating)
+		return;
+
+	detach(c);
+	detachstack(c);
+
+	setclientstate(c, WithdrawnState);
+	XUnmapWindow(dpy, p->win);
+
+	p->swallowing = c;
+	c->mon = p->mon;
+
+	Window w = p->win;
+	p->win = c->win;
+	c->win = w;
+	updatetitle(p);
+	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
+	arrange(p->mon);
+	configure(p);
+	updateclientlist();
+}
+
+void
+unswallow(Client *c)
+{
+	c->win = c->swallowing->win;
+
+	free(c->swallowing);
+	c->swallowing = NULL;
+
+	/* unfullscreen the client */
+	setfullscreen(c, 0);
+	updatetitle(c);
+	arrange(c->mon);
+	XMapWindow(dpy, c->win);
+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+	setclientstate(c, NormalState);
+	focus(NULL);
+	arrange(c->mon);
+}
+
+void
+buttonpress(XEvent *e)
+{
+	unsigned int i, x, click;
+	Arg arg = {0};
+	Client *c;
+	Monitor *m;
+	XButtonPressedEvent *ev = &e->xbutton;
+
+	click = ClkRootWin;
+	/* focus monitor if necessary */
+	if ((m = wintomon(ev->window)) && m != selmon) {
+		unfocus(selmon->sel, 1);
+		selmon = m;
+		focus(NULL);
+	}
+	if (ev->window == selmon->barwin) {
+		i = x = 0;
+		do
+			x += TEXTW(tags[i]);
+		while (ev->x >= x && ++i < LENGTH(tags));
+		if (i < LENGTH(tags)) {
+			click = ClkTagBar;
+			arg.ui = 1 << i;
+		} else if (ev->x < x + blw)
+			click = ClkLtSymbol;
+		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+			click = ClkStatusText;
+		else
+			click = ClkWinTitle;
+	} else if ((c = wintoclient(ev->window))) {
+		focus(c);
+		restack(selmon);
+		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+		click = ClkClientWin;
+	}
+	for (i = 0; i < LENGTH(buttons); i++)
+		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
+		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
+			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
+}
+
+void
+checkotherwm(void)
+{
+	xerrorxlib = XSetErrorHandler(xerrorstart);
+	/* this causes an error if some other window manager is running */
+	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
+	XSync(dpy, False);
+	XSetErrorHandler(xerror);
+	XSync(dpy, False);
+}
+
+void
+cleanup(void)
+{
+	Arg a = {.ui = ~0};
+	Layout foo = { "", NULL };
+	Monitor *m;
+	size_t i;
+
+	view(&a);
+	selmon->lt[selmon->sellt] = &foo;
+	for (m = mons; m; m = m->next)
+		while (m->stack)
+			unmanage(m->stack, 0);
+	XUngrabKey(dpy, AnyKey, AnyModifier, root);
+	while (mons)
+		cleanupmon(mons);
+	for (i = 0; i < CurLast; i++)
+		drw_cur_free(drw, cursor[i]);
+	for (i = 0; i < LENGTH(colors) + 1; i++)
+		free(scheme[i]);
+	XDestroyWindow(dpy, wmcheckwin);
+	drw_free(drw);
+	XSync(dpy, False);
+	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
+	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+}
+
+void
+cleanupmon(Monitor *mon)
+{
+	Monitor *m;
+
+	if (mon == mons)
+		mons = mons->next;
+	else {
+		for (m = mons; m && m->next != mon; m = m->next);
+		m->next = mon->next;
+	}
+	XUnmapWindow(dpy, mon->barwin);
+	XDestroyWindow(dpy, mon->barwin);
+	free(mon);
+}
+
+void
+clientmessage(XEvent *e)
+{
+	XClientMessageEvent *cme = &e->xclient;
+	Client *c = wintoclient(cme->window);
+	unsigned int i;
+
+	if (!c)
+		return;
+	if (cme->message_type == netatom[NetWMState]) {
+		if (cme->data.l[1] == netatom[NetWMFullscreen]
+		|| cme->data.l[2] == netatom[NetWMFullscreen])
+			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+	} else if (cme->message_type == netatom[NetActiveWindow]) {
+		for (i = 0; i < LENGTH(tags) && !((1 << i) & c->tags); i++);
+		if (i < LENGTH(tags)) {
+			const Arg a = {.ui = 1 << i};
+			selmon = c->mon;
+			view(&a);
+			focus(c);
+			restack(selmon);
+		}
+	}
+}
+
+void
+configure(Client *c)
+{
+	XConfigureEvent ce;
+
+	ce.type = ConfigureNotify;
+	ce.display = dpy;
+	ce.event = c->win;
+	ce.window = c->win;
+	ce.x = c->x;
+	ce.y = c->y;
+	ce.width = c->w;
+	ce.height = c->h;
+	ce.border_width = c->bw;
+	ce.above = None;
+	ce.override_redirect = False;
+	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
+}
+
+void
+configurenotify(XEvent *e)
+{
+	Monitor *m;
+	Client *c;
+	XConfigureEvent *ev = &e->xconfigure;
+	int dirty;
+
+	/* TODO: updategeom handling sucks, needs to be simplified */
+	if (ev->window == root) {
+		dirty = (sw != ev->width || sh != ev->height);
+		sw = ev->width;
+		sh = ev->height;
+		if (updategeom() || dirty) {
+			drw_resize(drw, sw, bh);
+			updatebars();
+			for (m = mons; m; m = m->next) {
+				for (c = m->clients; c; c = c->next)
+					if (c->isfullscreen)
+						resizeclient(c, m->mx, m->my, m->mw, m->mh);
+				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+			}
+			focus(NULL);
+			arrange(NULL);
+		}
+	}
+}
+
+void
+configurerequest(XEvent *e)
+{
+	Client *c;
+	Monitor *m;
+	XConfigureRequestEvent *ev = &e->xconfigurerequest;
+	XWindowChanges wc;
+
+	if ((c = wintoclient(ev->window))) {
+		if (ev->value_mask & CWBorderWidth)
+			c->bw = ev->border_width;
+		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
+			m = c->mon;
+			if (ev->value_mask & CWX) {
+				c->oldx = c->x;
+				c->x = m->mx + ev->x;
+			}
+			if (ev->value_mask & CWY) {
+				c->oldy = c->y;
+				c->y = m->my + ev->y;
+			}
+			if (ev->value_mask & CWWidth) {
+				c->oldw = c->w;
+				c->w = ev->width;
+			}
+			if (ev->value_mask & CWHeight) {
+				c->oldh = c->h;
+				c->h = ev->height;
+			}
+			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
+				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
+			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
+				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
+			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
+				configure(c);
+			if (ISVISIBLE(c))
+				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+		} else
+			configure(c);
+	} else {
+		wc.x = ev->x;
+		wc.y = ev->y;
+		wc.width = ev->width;
+		wc.height = ev->height;
+		wc.border_width = ev->border_width;
+		wc.sibling = ev->above;
+		wc.stack_mode = ev->detail;
+		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
+	}
+	XSync(dpy, False);
+}
+
+Monitor *
+createmon(void)
+{
+	Monitor *m;
+
+	m = ecalloc(1, sizeof(Monitor));
+	m->tagset[0] = m->tagset[1] = 1;
+	m->mfact = mfact;
+	m->nmaster = nmaster;
+	m->showbar = showbar;
+	m->topbar = topbar;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
+	m->lt[0] = &layouts[0];
+	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+	return m;
+}
+
+void
+destroynotify(XEvent *e)
+{
+	Client *c;
+	XDestroyWindowEvent *ev = &e->xdestroywindow;
+
+	if ((c = wintoclient(ev->window)))
+		unmanage(c, 1);
+
+	else if ((c = swallowingclient(ev->window)))
+		unmanage(c->swallowing, 1);
+}
+
+void
+detach(Client *c)
+{
+	Client **tc;
+
+	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
+	*tc = c->next;
+}
+
+void
+detachstack(Client *c)
+{
+	Client **tc, *t;
+
+	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
+	*tc = c->snext;
+
+	if (c == c->mon->sel) {
+		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
+		c->mon->sel = t;
+	}
+}
+
+Monitor *
+dirtomon(int dir)
+{
+	Monitor *m = NULL;
+
+	if (dir > 0) {
+		if (!(m = selmon->next))
+			m = mons;
+	} else if (selmon == mons)
+		for (m = mons; m->next; m = m->next);
+	else
+		for (m = mons; m->next != selmon; m = m->next);
+	return m;
+}
+
+int
+drawstatusbar(Monitor *m, int bh, char* stext) {
+	int ret, i, w, x, len;
+	short isCode = 0;
+	char *text;
+	char *p;
+
+	len = strlen(stext) + 1 ;
+	if (!(text = (char*) malloc(sizeof(char)*len)))
+		die("malloc");
+	p = text;
+	memcpy(text, stext, len);
+
+	/* compute width of the status text */
+	w = 0;
+	i = -1;
+	while (text[++i]) {
+		if (text[i] == '^') {
+			if (!isCode) {
+				isCode = 1;
+				text[i] = '\0';
+				w += TEXTW(text) - lrpad;
+				text[i] = '^';
+				if (text[++i] == 'f')
+					w += atoi(text + ++i);
+			} else {
+				isCode = 0;
+				text = text + i + 1;
+				i = -1;
+			}
+		}
+	}
+	if (!isCode)
+		w += TEXTW(text) - lrpad;
+	else
+		isCode = 0;
+	text = p;
+
+	w += 2; /* 1px padding on both sides */
+	ret = x = m->ww - w;
+
+	drw_setscheme(drw, scheme[LENGTH(colors)]);
+	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+	drw_rect(drw, x, 0, w, bh, 1, 1);
+	x++;
+
+	/* process status text */
+	i = -1;
+	while (text[++i]) {
+		if (text[i] == '^' && !isCode) {
+			isCode = 1;
+
+			text[i] = '\0';
+			w = TEXTW(text) - lrpad;
+			drw_text(drw, x, 0, w, bh, 0, text, 0);
+
+			x += w;
+
+			/* process code */
+			while (text[++i] != '^') {
+				if (text[i] == 'c') {
+					char buf[8];
+					memcpy(buf, (char*)text+i+1, 7);
+					buf[7] = '\0';
+					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+					i += 7;
+				} else if (text[i] == 'b') {
+					char buf[8];
+					memcpy(buf, (char*)text+i+1, 7);
+					buf[7] = '\0';
+					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+					i += 7;
+				} else if (text[i] == 'd') {
+					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+				} else if (text[i] == 'r') {
+					int rx = atoi(text + ++i);
+					while (text[++i] != ',');
+					int ry = atoi(text + ++i);
+					while (text[++i] != ',');
+					int rw = atoi(text + ++i);
+					while (text[++i] != ',');
+					int rh = atoi(text + ++i);
+
+					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+				} else if (text[i] == 'f') {
+					x += atoi(text + ++i);
+				}
+			}
+
+			text = text + i + 1;
+			i=-1;
+			isCode = 0;
+		}
+	}
+
+	if (!isCode) {
+		w = TEXTW(text) - lrpad;
+		drw_text(drw, x, 0, w, bh, 0, text, 0);
+	}
+
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	free(p);
+
+	return ret;
+}
+
+void
+drawbar(Monitor *m)
+{
+	int x, w, tw = 0;
+	int boxs = drw->fonts->h / 9;
+	int boxw = drw->fonts->h / 6 + 2;
+	unsigned int i, occ = 0, urg = 0;
+	Client *c;
+
+	/* draw status first so it can be overdrawn by tags later */
+	if (m == selmon) { /* status is only drawn on selected monitor */
+		tw = m->ww - drawstatusbar(m, bh, stext);
+	}
+
+	for (c = m->clients; c; c = c->next) {
+		occ |= c->tags;
+		if (c->isurgent)
+			urg |= c->tags;
+	}
+	x = 0;
+	for (i = 0; i < LENGTH(tags); i++) {
+		w = TEXTW(tags[i]);
+		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+		if (occ & 1 << i)
+			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+				urg & 1 << i);
+		x += w;
+	}
+	w = blw = TEXTW(m->ltsymbol);
+	drw_setscheme(drw, scheme[SchemeNorm]);
+	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+
+	if ((w = m->ww - tw - x) > bh) {
+		if (m->sel) {
+			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+			if (m->sel->isfloating)
+				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+		} else {
+			drw_setscheme(drw, scheme[SchemeNorm]);
+			drw_rect(drw, x, 0, w, bh, 1, 1);
+		}
+	}
+	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+}
+
+void
+drawbars(void)
+{
+	Monitor *m;
+
+	for (m = mons; m; m = m->next)
+		drawbar(m);
+}
+
+void
+enternotify(XEvent *e)
+{
+	Client *c;
+	Monitor *m;
+	XCrossingEvent *ev = &e->xcrossing;
+
+	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+		return;
+	c = wintoclient(ev->window);
+	m = c ? c->mon : wintomon(ev->window);
+	if (m != selmon) {
+		unfocus(selmon->sel, 1);
+		selmon = m;
+	} else if (!c || c == selmon->sel)
+		return;
+	focus(c);
+}
+
+void
+expose(XEvent *e)
+{
+	Monitor *m;
+	XExposeEvent *ev = &e->xexpose;
+
+	if (ev->count == 0 && (m = wintomon(ev->window)))
+		drawbar(m);
+}
+
+void
+focus(Client *c)
+{
+	if (!c || !ISVISIBLE(c))
+		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
+	if (selmon->sel && selmon->sel != c)
+		unfocus(selmon->sel, 0);
+	if (c) {
+		if (c->mon != selmon)
+			selmon = c->mon;
+		if (c->isurgent)
+			seturgent(c, 0);
+		detachstack(c);
+		attachstack(c);
+		grabbuttons(c, 1);
+		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
+		setfocus(c);
+	} else {
+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+	}
+	selmon->sel = c;
+	drawbars();
+}
+
+/* there are some broken focus acquiring clients needing extra handling */
+void
+focusin(XEvent *e)
+{
+	XFocusChangeEvent *ev = &e->xfocus;
+
+	if (selmon->sel && ev->window != selmon->sel->win)
+		setfocus(selmon->sel);
+}
+
+void
+focusmon(const Arg *arg)
+{
+	Monitor *m;
+
+	if (!mons->next)
+		return;
+	if ((m = dirtomon(arg->i)) == selmon)
+		return;
+	unfocus(selmon->sel, 0);
+	selmon = m;
+	focus(NULL);
+}
+
+void
+focusstack(const Arg *arg)
+{
+	Client *c = NULL, *i;
+
+	if (!selmon->sel)
+		return;
+	if (arg->i > 0) {
+		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+		if (!c)
+			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+	} else {
+		for (i = selmon->clients; i != selmon->sel; i = i->next)
+			if (ISVISIBLE(i))
+				c = i;
+		if (!c)
+			for (; i; i = i->next)
+				if (ISVISIBLE(i))
+					c = i;
+	}
+	if (c) {
+		focus(c);
+		restack(selmon);
+	}
+}
+
+Atom
+getatomprop(Client *c, Atom prop)
+{
+	int di;
+	unsigned long dl;
+	unsigned char *p = NULL;
+	Atom da, atom = None;
+
+	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
+		&da, &di, &dl, &dl, &p) == Success && p) {
+		atom = *(Atom *)p;
+		XFree(p);
+	}
+	return atom;
+}
+
+int
+getrootptr(int *x, int *y)
+{
+	int di;
+	unsigned int dui;
+	Window dummy;
+
+	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
+}
+
+long
+getstate(Window w)
+{
+	int format;
+	long result = -1;
+	unsigned char *p = NULL;
+	unsigned long n, extra;
+	Atom real;
+
+	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
+		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
+		return -1;
+	if (n != 0)
+		result = *p;
+	XFree(p);
+	return result;
+}
+
+int
+gettextprop(Window w, Atom atom, char *text, unsigned int size)
+{
+	char **list = NULL;
+	int n;
+	XTextProperty name;
+
+	if (!text || size == 0)
+		return 0;
+	text[0] = '\0';
+	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
+		return 0;
+	if (name.encoding == XA_STRING)
+		strncpy(text, (char *)name.value, size - 1);
+	else {
+		if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
+			strncpy(text, *list, size - 1);
+			XFreeStringList(list);
+		}
+	}
+	text[size - 1] = '\0';
+	XFree(name.value);
+	return 1;
+}
+
+void
+grabbuttons(Client *c, int focused)
+{
+	updatenumlockmask();
+	{
+		unsigned int i, j;
+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+		if (!focused)
+			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
+				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
+		for (i = 0; i < LENGTH(buttons); i++)
+			if (buttons[i].click == ClkClientWin)
+				for (j = 0; j < LENGTH(modifiers); j++)
+					XGrabButton(dpy, buttons[i].button,
+						buttons[i].mask | modifiers[j],
+						c->win, False, BUTTONMASK,
+						GrabModeAsync, GrabModeSync, None, None);
+	}
+}
+
+void
+grabkeys(void)
+{
+	updatenumlockmask();
+	{
+		unsigned int i, j;
+		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+		KeyCode code;
+
+		XUngrabKey(dpy, AnyKey, AnyModifier, root);
+		for (i = 0; i < LENGTH(keys); i++)
+			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
+				for (j = 0; j < LENGTH(modifiers); j++)
+					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
+						True, GrabModeAsync, GrabModeAsync);
+	}
+}
+
+void
+incnmaster(const Arg *arg)
+{
+	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	arrange(selmon);
+}
+
+#ifdef XINERAMA
+static int
+isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
+{
+	while (n--)
+		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
+		&& unique[n].width == info->width && unique[n].height == info->height)
+			return 0;
+	return 1;
+}
+#endif /* XINERAMA */
+
+void
+keypress(XEvent *e)
+{
+	unsigned int i;
+	KeySym keysym;
+	XKeyEvent *ev;
+
+	ev = &e->xkey;
+	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
+	for (i = 0; i < LENGTH(keys); i++)
+		if (keysym == keys[i].keysym
+		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
+		&& keys[i].func)
+			keys[i].func(&(keys[i].arg));
+}
+
+void
+killclient(const Arg *arg)
+{
+	if (!selmon->sel)
+		return;
+	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
+		XGrabServer(dpy);
+		XSetErrorHandler(xerrordummy);
+		XSetCloseDownMode(dpy, DestroyAll);
+		XKillClient(dpy, selmon->sel->win);
+		XSync(dpy, False);
+		XSetErrorHandler(xerror);
+		XUngrabServer(dpy);
+	}
+}
+
+void
+manage(Window w, XWindowAttributes *wa)
+{
+	Client *c, *t = NULL, *term = NULL;
+	Window trans = None;
+	XWindowChanges wc;
+
+	c = ecalloc(1, sizeof(Client));
+	c->win = w;
+	c->pid = winpid(w);
+	/* geometry */
+	c->x = c->oldx = wa->x;
+	c->y = c->oldy = wa->y;
+	c->w = c->oldw = wa->width;
+	c->h = c->oldh = wa->height;
+	c->oldbw = wa->border_width;
+
+	updatetitle(c);
+	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+		c->mon = t->mon;
+		c->tags = t->tags;
+	} else {
+		c->mon = selmon;
+		applyrules(c);
+		term = termforwin(c);
+	}
+
+	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
+		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
+	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
+		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
+	c->x = MAX(c->x, c->mon->mx);
+	/* only fix client y-offset, if the client center might cover the bar */
+	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
+		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
+	c->bw = borderpx;
+
+	wc.border_width = c->bw;
+	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
+	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
+	configure(c); /* propagates border_width, if size doesn't change */
+	updatewindowtype(c);
+	updatesizehints(c);
+	updatewmhints(c);
+	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+	grabbuttons(c, 0);
+	if (!c->isfloating)
+		c->isfloating = c->oldstate = trans != None || c->isfixed;
+	if (c->isfloating)
+		XRaiseWindow(dpy, c->win);
+	switch(attachdirection){
+		case 1:
+			attachabove(c);
+			break;
+		case 2:
+			attachaside(c);
+			break;
+		case 3:
+			attachbelow(c);
+			break;
+		case 4:
+			attachbottom(c);
+			break;
+		case 5:
+			attachtop(c);
+			break;
+		default:
+			attach(c);
+	}
+	attachstack(c);
+	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
+		(unsigned char *) &(c->win), 1);
+	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
+	setclientstate(c, NormalState);
+	if (c->mon == selmon)
+		unfocus(selmon->sel, 0);
+	c->mon->sel = c;
+	arrange(c->mon);
+	XMapWindow(dpy, c->win);
+	if (term)
+		swallow(term, c);
+	focus(NULL);
+}
+
+void
+mappingnotify(XEvent *e)
+{
+	XMappingEvent *ev = &e->xmapping;
+
+	XRefreshKeyboardMapping(ev);
+	if (ev->request == MappingKeyboard)
+		grabkeys();
+}
+
+void
+maprequest(XEvent *e)
+{
+	static XWindowAttributes wa;
+	XMapRequestEvent *ev = &e->xmaprequest;
+
+	if (!XGetWindowAttributes(dpy, ev->window, &wa))
+		return;
+	if (wa.override_redirect)
+		return;
+	if (!wintoclient(ev->window))
+		manage(ev->window, &wa);
+}
+
+void
+monocle(Monitor *m)
+{
+	unsigned int n = 0;
+	Client *c;
+
+	for (c = m->clients; c; c = c->next)
+		if (ISVISIBLE(c))
+			n++;
+	if (n > 0) /* override layout symbol */
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
+		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+}
+
+void
+motionnotify(XEvent *e)
+{
+	static Monitor *mon = NULL;
+	Monitor *m;
+	XMotionEvent *ev = &e->xmotion;
+
+	if (ev->window != root)
+		return;
+	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+		unfocus(selmon->sel, 1);
+		selmon = m;
+		focus(NULL);
+	}
+	mon = m;
+}
+
+void
+movemouse(const Arg *arg)
+{
+	int x, y, ocx, ocy, nx, ny;
+	Client *c;
+	Monitor *m;
+	XEvent ev;
+	Time lasttime = 0;
+
+	if (!(c = selmon->sel))
+		return;
+	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+		return;
+	restack(selmon);
+	ocx = c->x;
+	ocy = c->y;
+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
+		return;
+	if (!getrootptr(&x, &y))
+		return;
+	do {
+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+		switch(ev.type) {
+		case ConfigureRequest:
+		case Expose:
+		case MapRequest:
+			handler[ev.type](&ev);
+			break;
+		case MotionNotify:
+			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
+				continue;
+			lasttime = ev.xmotion.time;
+
+			nx = ocx + (ev.xmotion.x - x);
+			ny = ocy + (ev.xmotion.y - y);
+			if (abs(selmon->wx - nx) < snap)
+				nx = selmon->wx;
+			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
+				nx = selmon->wx + selmon->ww - WIDTH(c);
+			if (abs(selmon->wy - ny) < snap)
+				ny = selmon->wy;
+			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
+				ny = selmon->wy + selmon->wh - HEIGHT(c);
+			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
+				togglefloating(NULL);
+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+				resize(c, nx, ny, c->w, c->h, 1);
+			break;
+		}
+	} while (ev.type != ButtonRelease);
+	XUngrabPointer(dpy, CurrentTime);
+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+		sendmon(c, m);
+		selmon = m;
+		focus(NULL);
+	}
+}
+
+Client *
+nexttagged(Client *c) {
+	Client *walked = c->mon->clients;
+	for(;
+		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
+		walked = walked->next
+	);
+	return walked;
+}
+
+Client *
+nexttiled(Client *c)
+{
+	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
+	return c;
+}
+
+void
+pop(Client *c)
+{
+	detach(c);
+	attach(c);
+	focus(c);
+	arrange(c->mon);
+}
+
+Client *
+prevtiled(Client *c) {
+	Client *p, *r;
+
+	for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
+		if(!p->isfloating && ISVISIBLE(p))
+			r = p;
+	return r;
+}
+
+void
+propertynotify(XEvent *e)
+{
+	Client *c;
+	Window trans;
+	XPropertyEvent *ev = &e->xproperty;
+
+	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
+		updatestatus();
+	else if (ev->state == PropertyDelete)
+		return; /* ignore */
+	else if ((c = wintoclient(ev->window))) {
+		switch(ev->atom) {
+		default: break;
+		case XA_WM_TRANSIENT_FOR:
+			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
+				(c->isfloating = (wintoclient(trans)) != NULL))
+				arrange(c->mon);
+			break;
+		case XA_WM_NORMAL_HINTS:
+			updatesizehints(c);
+			break;
+		case XA_WM_HINTS:
+			updatewmhints(c);
+			drawbars();
+			break;
+		}
+		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+			updatetitle(c);
+			if (c == c->mon->sel)
+				drawbar(c->mon);
+		}
+		if (ev->atom == netatom[NetWMWindowType])
+			updatewindowtype(c);
+	}
+}
+
+void
+pushdown(const Arg *arg) {
+	Client *sel = selmon->sel, *c;
+
+	if(!sel || sel->isfloating || sel == nexttiled(selmon->clients))
+		return;
+	if((c = nexttiled(sel->next))) {
+		detach(sel);
+		sel->next = c->next;
+		c->next = sel;
+	}
+	focus(sel);
+	arrange(selmon);
+}
+
+void
+pushup(const Arg *arg) {
+	Client *sel = selmon->sel, *c;
+
+	if(!sel || sel->isfloating)
+		return;
+	if((c = prevtiled(sel)) && c != nexttiled(selmon->clients)) {
+		detach(sel);
+		sel->next = c;
+		for(c = selmon->clients; c->next != sel->next; c = c->next);
+		c->next = sel;
+	}
+	focus(sel);
+	arrange(selmon);
+}
+
+void
+quit(const Arg *arg)
+{
+	if(arg->i) restart = 1;
+	running = 0;
+}
+
+Monitor *
+recttomon(int x, int y, int w, int h)
+{
+	Monitor *m, *r = selmon;
+	int a, area = 0;
+
+	for (m = mons; m; m = m->next)
+		if ((a = INTERSECT(x, y, w, h, m)) > area) {
+			area = a;
+			r = m;
+		}
+	return r;
+}
+
+void
+resize(Client *c, int x, int y, int w, int h, int interact)
+{
+	if (applysizehints(c, &x, &y, &w, &h, interact))
+		resizeclient(c, x, y, w, h);
+}
+
+void
+resizeclient(Client *c, int x, int y, int w, int h)
+{
+	XWindowChanges wc;
+
+	c->oldx = c->x; c->x = wc.x = x;
+	c->oldy = c->y; c->y = wc.y = y;
+	c->oldw = c->w; c->w = wc.width = w;
+	c->oldh = c->h; c->h = wc.height = h;
+	wc.border_width = c->bw;
+	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
+	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
+	    && !c->isfullscreen && !c->isfloating
+	    && NULL != c->mon->lt[c->mon->sellt]->arrange) {
+		c->w = wc.width += c->bw * 2;
+		c->h = wc.height += c->bw * 2;
+		wc.border_width = 0;
+	}
+	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+	configure(c);
+	XSync(dpy, False);
+}
+
+void
+resizemouse(const Arg *arg)
+{
+	int ocx, ocy, nw, nh;
+	Client *c;
+	Monitor *m;
+	XEvent ev;
+	Time lasttime = 0;
+
+	if (!(c = selmon->sel))
+		return;
+	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+		return;
+	restack(selmon);
+	ocx = c->x;
+	ocy = c->y;
+	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
+		return;
+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+	do {
+		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+		switch(ev.type) {
+		case ConfigureRequest:
+		case Expose:
+		case MapRequest:
+			handler[ev.type](&ev);
+			break;
+		case MotionNotify:
+			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
+				continue;
+			lasttime = ev.xmotion.time;
+
+			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
+			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
+			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
+			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
+			{
+				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
+					togglefloating(NULL);
+			}
+			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+				resize(c, c->x, c->y, nw, nh, 1);
+			break;
+		}
+	} while (ev.type != ButtonRelease);
+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+	XUngrabPointer(dpy, CurrentTime);
+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+		sendmon(c, m);
+		selmon = m;
+		focus(NULL);
+	}
+}
+
+void
+restack(Monitor *m)
+{
+	Client *c;
+	XEvent ev;
+	XWindowChanges wc;
+
+	drawbar(m);
+	if (!m->sel)
+		return;
+	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
+		XRaiseWindow(dpy, m->sel->win);
+	if (m->lt[m->sellt]->arrange) {
+		wc.stack_mode = Below;
+		wc.sibling = m->barwin;
+		for (c = m->stack; c; c = c->snext)
+			if (!c->isfloating && ISVISIBLE(c)) {
+				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
+				wc.sibling = c->win;
+			}
+	}
+	XSync(dpy, False);
+	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+}
+
+void
+run(void)
+{
+	XEvent ev;
+	/* main event loop */
+	XSync(dpy, False);
+	while (running && !XNextEvent(dpy, &ev))
+		if (handler[ev.type])
+			handler[ev.type](&ev); /* call handler */
+}
+
+void
+runautostart(void)
+{
+	char *pathpfx;
+	char *path;
+	char *xdgdatahome;
+	char *home;
+	struct stat sb;
+
+	if ((home = getenv("HOME")) == NULL)
+		/* this is almost impossible */
+		return;
+
+	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+	 * otherwise use ~/.local/share/dwm as autostart script directory
+	 */
+	xdgdatahome = getenv("XDG_DATA_HOME");
+	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+		/* space for path segments, separators and nul */
+		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+
+		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	} else {
+		/* space for path segments, separators and nul */
+		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+		                     + strlen(dwmdir) + 3);
+
+		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* check if the autostart script directory exists */
+	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+		/* the XDG conformant path does not exist or is no directory
+		 * so we try ~/.dwm instead
+		 */
+		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+		if(pathpfx_new == NULL) {
+			free(pathpfx);
+			return;
+		}
+   pathpfx = pathpfx_new;
+
+		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* try the blocking script first */
+	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(path);
+
+	/* now the non-blocking script */
+	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+		free(path);
+		free(pathpfx);
+	}
+
+	if (access(path, X_OK) == 0)
+		system(strcat(path, " &"));
+
+	free(pathpfx);
+	free(path);
+}
+
+void
+scan(void)
+{
+	unsigned int i, num;
+	Window d1, d2, *wins = NULL;
+	XWindowAttributes wa;
+
+	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
+		for (i = 0; i < num; i++) {
+			if (!XGetWindowAttributes(dpy, wins[i], &wa)
+			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
+				continue;
+			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
+				manage(wins[i], &wa);
+		}
+		for (i = 0; i < num; i++) { /* now the transients */
+			if (!XGetWindowAttributes(dpy, wins[i], &wa))
+				continue;
+			if (XGetTransientForHint(dpy, wins[i], &d1)
+			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
+				manage(wins[i], &wa);
+		}
+		if (wins)
+			XFree(wins);
+	}
+}
+
+void
+sendmon(Client *c, Monitor *m)
+{
+	if (c->mon == m)
+		return;
+	unfocus(c, 1);
+	detach(c);
+	detachstack(c);
+	c->mon = m;
+	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+	switch(attachdirection){
+		case 1:
+			attachabove(c);
+			break;
+		case 2:
+			attachaside(c);
+			break;
+		case 3:
+			attachbelow(c);
+			break;
+		case 4:
+			attachbottom(c);
+			break;
+		case 5:
+			attachtop(c);
+			break;
+		default:
+			attach(c);
+	}
+	attachstack(c);
+	focus(NULL);
+	arrange(NULL);
+}
+
+void
+setclientstate(Client *c, long state)
+{
+	long data[] = { state, None };
+
+	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
+		PropModeReplace, (unsigned char *)data, 2);
+}
+
+int
+sendevent(Client *c, Atom proto)
+{
+	int n;
+	Atom *protocols;
+	int exists = 0;
+	XEvent ev;
+
+	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
+		while (!exists && n--)
+			exists = protocols[n] == proto;
+		XFree(protocols);
+	}
+	if (exists) {
+		ev.type = ClientMessage;
+		ev.xclient.window = c->win;
+		ev.xclient.message_type = wmatom[WMProtocols];
+		ev.xclient.format = 32;
+		ev.xclient.data.l[0] = proto;
+		ev.xclient.data.l[1] = CurrentTime;
+		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
+	}
+	return exists;
+}
+
+void
+setfocus(Client *c)
+{
+	if (!c->neverfocus) {
+		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
+		XChangeProperty(dpy, root, netatom[NetActiveWindow],
+			XA_WINDOW, 32, PropModeReplace,
+			(unsigned char *) &(c->win), 1);
+	}
+	sendevent(c, wmatom[WMTakeFocus]);
+}
+
+void
+setfullscreen(Client *c, int fullscreen)
+{
+	if (fullscreen && !c->isfullscreen) {
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+		c->isfullscreen = 1;
+		c->oldstate = c->isfloating;
+		c->oldbw = c->bw;
+		c->bw = 0;
+		c->isfloating = 1;
+		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+		XRaiseWindow(dpy, c->win);
+	} else if (!fullscreen && c->isfullscreen){
+		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+			PropModeReplace, (unsigned char*)0, 0);
+		c->isfullscreen = 0;
+		c->isfloating = c->oldstate;
+		c->bw = c->oldbw;
+		c->x = c->oldx;
+		c->y = c->oldy;
+		c->w = c->oldw;
+		c->h = c->oldh;
+		resizeclient(c, c->x, c->y, c->w, c->h);
+		arrange(c->mon);
+	}
+}
+
+void
+setlayout(const Arg *arg)
+{
+	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+		selmon->sellt ^= 1;
+	if (arg && arg->v)
+		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+	if (selmon->sel)
+		arrange(selmon);
+	else
+		drawbar(selmon);
+}
+
+/* arg > 1.0 will set mfact absolutely */
+void
+setmfact(const Arg *arg)
+{
+	float f;
+
+	if (!arg || !selmon->lt[selmon->sellt]->arrange)
+		return;
+	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+	if (f < 0.05 || f > 0.95)
+		return;
+	selmon->mfact = f;
+	arrange(selmon);
+}
+
+void
+setup(void)
+{
+	int i;
+	XSetWindowAttributes wa;
+	Atom utf8string;
+
+	/* clean up any zombies immediately */
+	sigchld(0);
+
+	signal(SIGHUP, sighup);
+	signal(SIGTERM, sigterm);
+
+	/* init screen */
+	screen = DefaultScreen(dpy);
+	sw = DisplayWidth(dpy, screen);
+	sh = DisplayHeight(dpy, screen);
+	root = RootWindow(dpy, screen);
+	drw = drw_create(dpy, screen, root, sw, sh);
+	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+		die("no fonts could be loaded.");
+	lrpad = drw->fonts->h;
+	bh = user_bh ? user_bh : drw->fonts->h + 2;
+	updategeom();
+	/* init atoms */
+	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
+	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
+	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
+	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
+	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
+	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
+	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
+	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+	/* init cursors */
+	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
+	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+	/* init appearance */
+	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+	for (i = 0; i < LENGTH(colors); i++)
+		scheme[i] = drw_scm_create(drw, colors[i], 3);
+	/* init bars */
+	updatebars();
+	updatestatus();
+	/* supporting window for NetWMCheck */
+	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
+		PropModeReplace, (unsigned char *) "dwm", 3);
+	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
+		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+	/* EWMH support per view */
+	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
+		PropModeReplace, (unsigned char *) netatom, NetLast);
+	XDeleteProperty(dpy, root, netatom[NetClientList]);
+	/* select events */
+	wa.cursor = cursor[CurNormal]->cursor;
+	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
+		|ButtonPressMask|PointerMotionMask|EnterWindowMask
+		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
+	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
+	XSelectInput(dpy, root, wa.event_mask);
+	grabkeys();
+	focus(NULL);
+}
+
+
+void
+seturgent(Client *c, int urg)
+{
+	XWMHints *wmh;
+
+	c->isurgent = urg;
+	if (!(wmh = XGetWMHints(dpy, c->win)))
+		return;
+	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
+	XSetWMHints(dpy, c->win, wmh);
+	XFree(wmh);
+}
+
+void
+shiftviewclients(const Arg *arg)
+{
+	Arg shifted;
+	Client *c;
+	unsigned int tagmask = 0;
+
+	for (c = selmon->clients; c; c = c->next)
+		#if SCRATCHPADS_PATCH
+		if (!(c->tags & SPTAGMASK))
+			tagmask = tagmask | c->tags;
+		#else
+		tagmask = tagmask | c->tags;
+		#endif // SCRATCHPADS_PATCH
+
+	#if SCRATCHPADS_PATCH
+	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
+	#else
+	shifted.ui = selmon->tagset[selmon->seltags];
+	#endif // SCRATCHPADS_PATCH
+	if (arg->i > 0) // left circular shift
+		do {
+			shifted.ui = (shifted.ui << arg->i)
+			   | (shifted.ui >> (LENGTH(tags) - arg->i));
+			#if SCRATCHPADS_PATCH
+			shifted.ui &= ~SPTAGMASK;
+			#endif // SCRATCHPADS_PATCH
+		} while (tagmask && !(shifted.ui & tagmask));
+	else // right circular shift
+		do {
+			shifted.ui = (shifted.ui >> (- arg->i)
+			   | shifted.ui << (LENGTH(tags) + arg->i));
+			#if SCRATCHPADS_PATCH
+			shifted.ui &= ~SPTAGMASK;
+			#endif // SCRATCHPADS_PATCH
+		} while (tagmask && !(shifted.ui & tagmask));
+
+	view(&shifted);
+}
+
+void
+showhide(Client *c)
+{
+	if (!c)
+		return;
+	if (ISVISIBLE(c)) {
+		/* show clients top down */
+		XMoveWindow(dpy, c->win, c->x, c->y);
+		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+			resize(c, c->x, c->y, c->w, c->h, 0);
+		showhide(c->snext);
+	} else {
+		/* hide clients bottom up */
+		showhide(c->snext);
+		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
+	}
+}
+
+void
+sigchld(int unused)
+{
+	if (signal(SIGCHLD, sigchld) == SIG_ERR)
+		die("can't install SIGCHLD handler:");
+	while (0 < waitpid(-1, NULL, WNOHANG));
+}
+
+void
+sighup(int unused)
+{
+	Arg a = {.i = 1};
+	quit(&a);
+}
+
+void
+sigterm(int unused)
+{
+	Arg a = {.i = 0};
+	quit(&a);
+}
+
+void
+spawn(const Arg *arg)
+{
+	if (arg->v == dmenucmd)
+		dmenumon[0] = '0' + selmon->num;
+	if (fork() == 0) {
+		if (dpy)
+			close(ConnectionNumber(dpy));
+		setsid();
+		execvp(((char **)arg->v)[0], (char **)arg->v);
+		fprintf(stderr, "dwm: execvp %s", ((char **)arg->v)[0]);
+		perror(" failed");
+		exit(EXIT_SUCCESS);
+	}
+}
+
+void
+tag(const Arg *arg)
+{
+	if (selmon->sel && arg->ui & TAGMASK) {
+		selmon->sel->tags = arg->ui & TAGMASK;
+		focus(NULL);
+		arrange(selmon);
+	}
+}
+
+void
+tagmon(const Arg *arg)
+{
+	if (!selmon->sel || !mons->next)
+		return;
+	sendmon(selmon->sel, dirtomon(arg->i));
+}
+
+void
+togglebar(const Arg *arg)
+{
+	selmon->showbar = !selmon->showbar;
+	updatebarpos(selmon);
+	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+	arrange(selmon);
+}
+
+void
+togglefloating(const Arg *arg)
+{
+	if (!selmon->sel)
+		return;
+	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+		return;
+	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+	if (selmon->sel->isfloating)
+		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+			selmon->sel->w, selmon->sel->h, 0);
+	arrange(selmon);
+}
+
+void
+togglefullscr(const Arg *arg)
+{
+  if(selmon->sel)
+    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
+}
+
+void
+toggletag(const Arg *arg)
+{
+	unsigned int newtags;
+
+	if (!selmon->sel)
+		return;
+	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
+	if (newtags) {
+		selmon->sel->tags = newtags;
+		focus(NULL);
+		arrange(selmon);
+	}
+}
+
+void
+toggleview(const Arg *arg)
+{
+	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+
+	if (newtagset) {
+		selmon->tagset[selmon->seltags] = newtagset;
+		focus(NULL);
+		arrange(selmon);
+	}
+}
+
+void
+unfocus(Client *c, int setfocus)
+{
+	if (!c)
+		return;
+	grabbuttons(c, 0);
+	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
+	if (setfocus) {
+		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+	}
+}
+
+void
+unmanage(Client *c, int destroyed)
+{
+	Monitor *m = c->mon;
+	XWindowChanges wc;
+
+	if (c->swallowing) {
+		unswallow(c);
+		return;
+	}
+
+	Client *s = swallowingclient(c->win);
+	if (s) {
+		free(s->swallowing);
+		s->swallowing = NULL;
+		arrange(m);
+		focus(NULL);
+		return;
+	}
+
+	detach(c);
+	detachstack(c);
+	if (!destroyed) {
+		wc.border_width = c->oldbw;
+		XGrabServer(dpy); /* avoid race conditions */
+		XSetErrorHandler(xerrordummy);
+		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
+		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+		setclientstate(c, WithdrawnState);
+		XSync(dpy, False);
+		XSetErrorHandler(xerror);
+		XUngrabServer(dpy);
+	}
+	free(c);
+
+	if (!s) {
+		arrange(m);
+		focus(NULL);
+		updateclientlist();
+	}
+}
+
+void
+unmapnotify(XEvent *e)
+{
+	Client *c;
+	XUnmapEvent *ev = &e->xunmap;
+
+	if ((c = wintoclient(ev->window))) {
+		if (ev->send_event)
+			setclientstate(c, WithdrawnState);
+		else
+			unmanage(c, 0);
+	}
+}
+
+void
+updatebars(void)
+{
+	Monitor *m;
+	XSetWindowAttributes wa = {
+		.override_redirect = True,
+		.background_pixmap = ParentRelative,
+		.event_mask = ButtonPressMask|ExposureMask
+	};
+	XClassHint ch = {"dwm", "dwm"};
+	for (m = mons; m; m = m->next) {
+		if (m->barwin)
+			continue;
+		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+				CopyFromParent, DefaultVisual(dpy, screen),
+				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
+		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+		XMapRaised(dpy, m->barwin);
+		XSetClassHint(dpy, m->barwin, &ch);
+	}
+}
+
+void
+updatebarpos(Monitor *m)
+{
+	m->wy = m->my;
+	m->wh = m->mh;
+	if (m->showbar) {
+		m->wh -= bh;
+		m->by = m->topbar ? m->wy : m->wy + m->wh;
+		m->wy = m->topbar ? m->wy + bh : m->wy;
+	} else
+		m->by = -bh;
+}
+
+void
+updateclientlist()
+{
+	Client *c;
+	Monitor *m;
+
+	XDeleteProperty(dpy, root, netatom[NetClientList]);
+	for (m = mons; m; m = m->next)
+		for (c = m->clients; c; c = c->next)
+			XChangeProperty(dpy, root, netatom[NetClientList],
+				XA_WINDOW, 32, PropModeAppend,
+				(unsigned char *) &(c->win), 1);
+}
+
+int
+updategeom(void)
+{
+	int dirty = 0;
+
+#ifdef XINERAMA
+	if (XineramaIsActive(dpy)) {
+		int i, j, n, nn;
+		Client *c;
+		Monitor *m;
+		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
+		XineramaScreenInfo *unique = NULL;
+
+		for (n = 0, m = mons; m; m = m->next, n++);
+		/* only consider unique geometries as separate screens */
+		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
+		for (i = 0, j = 0; i < nn; i++)
+			if (isuniquegeom(unique, j, &info[i]))
+				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
+		XFree(info);
+		nn = j;
+		if (n <= nn) { /* new monitors available */
+			for (i = 0; i < (nn - n); i++) {
+				for (m = mons; m && m->next; m = m->next);
+				if (m)
+					m->next = createmon();
+				else
+					mons = createmon();
+			}
+			for (i = 0, m = mons; i < nn && m; m = m->next, i++)
+				if (i >= n
+				|| unique[i].x_org != m->mx || unique[i].y_org != m->my
+				|| unique[i].width != m->mw || unique[i].height != m->mh)
+				{
+					dirty = 1;
+					m->num = i;
+					m->mx = m->wx = unique[i].x_org;
+					m->my = m->wy = unique[i].y_org;
+					m->mw = m->ww = unique[i].width;
+					m->mh = m->wh = unique[i].height;
+					updatebarpos(m);
+				}
+		} else { /* less monitors available nn < n */
+			for (i = nn; i < n; i++) {
+				for (m = mons; m && m->next; m = m->next);
+				while ((c = m->clients)) {
+					dirty = 1;
+					m->clients = c->next;
+					detachstack(c);
+					c->mon = mons;
+					switch(attachdirection){
+					case 1:
+						attachabove(c);
+						break;
+					case 2:
+						attachaside(c);
+						break;
+					case 3:
+						attachbelow(c);
+						break;
+					case 4:
+						attachbottom(c);
+						break;
+					case 5:
+						attachtop(c);
+						break;
+					default:
+						attach(c);
+					}
+					attachstack(c);
+				}
+				if (m == selmon)
+					selmon = mons;
+				cleanupmon(m);
+			}
+		}
+		free(unique);
+	} else
+#endif /* XINERAMA */
+	{ /* default monitor setup */
+		if (!mons)
+			mons = createmon();
+		if (mons->mw != sw || mons->mh != sh) {
+			dirty = 1;
+			mons->mw = mons->ww = sw;
+			mons->mh = mons->wh = sh;
+			updatebarpos(mons);
+		}
+	}
+	if (dirty) {
+		selmon = mons;
+		selmon = wintomon(root);
+	}
+	return dirty;
+}
+
+void
+updatenumlockmask(void)
+{
+	unsigned int i, j;
+	XModifierKeymap *modmap;
+
+	numlockmask = 0;
+	modmap = XGetModifierMapping(dpy);
+	for (i = 0; i < 8; i++)
+		for (j = 0; j < modmap->max_keypermod; j++)
+			if (modmap->modifiermap[i * modmap->max_keypermod + j]
+				== XKeysymToKeycode(dpy, XK_Num_Lock))
+				numlockmask = (1 << i);
+	XFreeModifiermap(modmap);
+}
+
+void
+updatesizehints(Client *c)
+{
+	long msize;
+	XSizeHints size;
+
+	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
+		/* size is uninitialized, ensure that size.flags aren't used */
+		size.flags = PSize;
+	if (size.flags & PBaseSize) {
+		c->basew = size.base_width;
+		c->baseh = size.base_height;
+	} else if (size.flags & PMinSize) {
+		c->basew = size.min_width;
+		c->baseh = size.min_height;
+	} else
+		c->basew = c->baseh = 0;
+	if (size.flags & PResizeInc) {
+		c->incw = size.width_inc;
+		c->inch = size.height_inc;
+	} else
+		c->incw = c->inch = 0;
+	if (size.flags & PMaxSize) {
+		c->maxw = size.max_width;
+		c->maxh = size.max_height;
+	} else
+		c->maxw = c->maxh = 0;
+	if (size.flags & PMinSize) {
+		c->minw = size.min_width;
+		c->minh = size.min_height;
+	} else if (size.flags & PBaseSize) {
+		c->minw = size.base_width;
+		c->minh = size.base_height;
+	} else
+		c->minw = c->minh = 0;
+	if (size.flags & PAspect) {
+		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
+		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
+	} else
+		c->maxa = c->mina = 0.0;
+	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
+}
+
+void
+updatestatus(void)
+{
+	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+		strcpy(stext, "dwm-"VERSION);
+	drawbar(selmon);
+}
+
+void
+updatetitle(Client *c)
+{
+	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
+		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
+	if (c->name[0] == '\0') /* hack to mark broken clients */
+		strcpy(c->name, broken);
+}
+
+void
+updatewindowtype(Client *c)
+{
+	Atom state = getatomprop(c, netatom[NetWMState]);
+	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
+
+	if (state == netatom[NetWMFullscreen])
+		setfullscreen(c, 1);
+	if (wtype == netatom[NetWMWindowTypeDialog])
+		c->isfloating = 1;
+}
+
+void
+updatewmhints(Client *c)
+{
+	XWMHints *wmh;
+
+	if ((wmh = XGetWMHints(dpy, c->win))) {
+		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
+			wmh->flags &= ~XUrgencyHint;
+			XSetWMHints(dpy, c->win, wmh);
+		} else {
+			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
+			if (c->isurgent)
+				XSetWindowBorder(dpy, c->win, scheme[SchemeUrg][ColBorder].pixel);
+		}
+		if (wmh->flags & InputHint)
+			c->neverfocus = !wmh->input;
+		else
+			c->neverfocus = 0;
+		XFree(wmh);
+	}
+}
+
+void
+view(const Arg *arg)
+{
+	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+		return;
+	selmon->seltags ^= 1; /* toggle sel tagset */
+	if (arg->ui & TAGMASK)
+		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+	focus(NULL);
+	arrange(selmon);
+}
+
+pid_t
+winpid(Window w)
+{
+
+	pid_t result = 0;
+
+#ifdef __linux__
+	xcb_res_client_id_spec_t spec = {0};
+	spec.client = w;
+	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
+
+	xcb_generic_error_t *e = NULL;
+	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
+	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
+
+	if (!r)
+		return (pid_t)0;
+
+	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
+	for (; i.rem; xcb_res_client_id_value_next(&i)) {
+		spec = i.data->spec;
+		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
+			uint32_t *t = xcb_res_client_id_value_value(i.data);
+			result = *t;
+			break;
+		}
+	}
+
+	free(r);
+
+	if (result == (pid_t)-1)
+		result = 0;
+
+#endif /* __linux__ */
+
+#ifdef __OpenBSD__
+        Atom type;
+        int format;
+        unsigned long len, bytes;
+        unsigned char *prop;
+        pid_t ret;
+
+        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
+               return 0;
+
+        ret = *(pid_t*)prop;
+        XFree(prop);
+        result = ret;
+
+#endif /* __OpenBSD__ */
+	return result;
+}
+
+pid_t
+getparentprocess(pid_t p)
+{
+	unsigned int v = 0;
+
+#ifdef __linux__
+	FILE *f;
+	char buf[256];
+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+
+	if (!(f = fopen(buf, "r")))
+		return 0;
+
+	fscanf(f, "%*u %*s %*c %u", &v);
+	fclose(f);
+#endif /* __linux__*/
+
+#ifdef __OpenBSD__
+	int n;
+	kvm_t *kd;
+	struct kinfo_proc *kp;
+
+	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
+	if (!kd)
+		return 0;
+
+	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
+	v = kp->p_ppid;
+#endif /* __OpenBSD__ */
+
+	return (pid_t)v;
+}
+
+int
+isdescprocess(pid_t p, pid_t c)
+{
+	while (p != c && c != 0)
+		c = getparentprocess(c);
+
+	return (int)c;
+}
+
+Client *
+termforwin(const Client *w)
+{
+	Client *c;
+	Monitor *m;
+
+	if (!w->pid || w->isterminal)
+		return NULL;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
+				return c;
+		}
+	}
+
+	return NULL;
+}
+
+Client *
+swallowingclient(Window w)
+{
+	Client *c;
+	Monitor *m;
+
+	for (m = mons; m; m = m->next) {
+		for (c = m->clients; c; c = c->next) {
+			if (c->swallowing && c->swallowing->win == w)
+				return c;
+		}
+	}
+
+	return NULL;
+}
+
+Client *
+wintoclient(Window w)
+{
+	Client *c;
+	Monitor *m;
+
+	for (m = mons; m; m = m->next)
+		for (c = m->clients; c; c = c->next)
+			if (c->win == w)
+				return c;
+	return NULL;
+}
+
+Monitor *
+wintomon(Window w)
+{
+	int x, y;
+	Client *c;
+	Monitor *m;
+
+	if (w == root && getrootptr(&x, &y))
+		return recttomon(x, y, 1, 1);
+	for (m = mons; m; m = m->next)
+		if (w == m->barwin)
+			return m;
+	if ((c = wintoclient(w)))
+		return c->mon;
+	return selmon;
+}
+
+/* There's no way to check accesses to destroyed windows, thus those cases are
+ * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
+ * default error handler, which may call exit. */
+int
+xerror(Display *dpy, XErrorEvent *ee)
+{
+	if (ee->error_code == BadWindow
+	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
+	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
+	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
+	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
+	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
+	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
+	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
+	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
+		return 0;
+	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
+		ee->request_code, ee->error_code);
+	return xerrorxlib(dpy, ee); /* may call exit */
+}
+
+int
+xerrordummy(Display *dpy, XErrorEvent *ee)
+{
+	return 0;
+}
+
+/* Startup Error handler to check if another window manager
+ * is already running. */
+int
+xerrorstart(Display *dpy, XErrorEvent *ee)
+{
+	die("dwm: another window manager is already running");
+	return -1;
+}
+
+void
+zoom(const Arg *arg)
+{
+	Client *c = selmon->sel;
+
+	if (!selmon->lt[selmon->sellt]->arrange
+	|| (selmon->sel && selmon->sel->isfloating))
+		return;
+	if (c == nexttiled(selmon->clients))
+		if (!c || !(c = nexttiled(c->next)))
+			return;
+	pop(c);
+}
+
+int
+main(int argc, char *argv[])
+{
+	if (argc == 2 && !strcmp("-v", argv[1]))
+		die("dwm-"VERSION);
+	else if (argc != 1)
+		die("usage: dwm [-v]");
+	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+		fputs("warning: no locale support\n", stderr);
+	if (!(dpy = XOpenDisplay(NULL)))
+		die("dwm: cannot open display");
+	if (!(xcon = XGetXCBConnection(dpy)))
+		die("dwm: cannot get xcb connection\n");
+	checkotherwm();
+	setup();
+#ifdef __OpenBSD__
+	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+		die("pledge");
+#endif /* __OpenBSD__ */
+	scan();
+	runautostart();
+	run();
+	if(restart) execvp(argv[0], argv);
+	cleanup();
+	XCloseDisplay(dpy);
+	return EXIT_SUCCESS;
+}
Les fichiers binaires /home/fuzzbox/Téléchargements/dwm/dwm.o et ./dwm.o sont différents
Les sous-répertoires /home/fuzzbox/Téléchargements/dwm/.git et ./.git sont identiques
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/my-dwm.diff" ./my-dwm.diff
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/my-dwm.diff"	1970-01-01 01:00:00.000000000 +0100
+++ ./my-dwm.diff	2021-01-15 01:51:38.731509024 +0100
@@ -0,0 +1,4593 @@
+diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.def.h" ./config.def.h
+--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.def.h"	2021-01-13 22:22:32.377160109 +0100
++++ ./config.def.h	2021-01-15 01:24:57.328258658 +0100
+@@ -3,97 +3,160 @@
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 1;        /* 1 means swallow floating windows by default */
++static const unsigned int gappih    = 30;       /* horiz inner gap between windows */
++static const unsigned int gappiv    = 30;       /* vert inner gap between windows */
++static const unsigned int gappoh    = 30;       /* horiz outer gap between windows and screen edge */
++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++static       int smartgaps          = 1;        /* 1 means no outer gap when there is only one window */
+ static const int showbar            = 1;        /* 0 means no bar */
+-static const int topbar             = 1;        /* 0 means bottom bar */
+-static const char *fonts[]          = { "monospace:size=10" };
+-static const char dmenufont[]       = "monospace:size=10";
+-static const char col_gray1[]       = "#222222";
+-static const char col_gray2[]       = "#444444";
+-static const char col_gray3[]       = "#bbbbbb";
+-static const char col_gray4[]       = "#eeeeee";
+-static const char col_cyan[]        = "#005577";
+-static const char *colors[][3]      = {
+-	/*               fg         bg         border   */
+-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+-};
++static const int topbar             = 0;        /* 0 means bottom bar */
++static const int user_bh            = 32;        /* 0 means that dwm will calculate bar height, >= 1 means dwm will user_bh as bar height */
++static const char *fonts[]          = { "MesloLGS Nerd Font:size=10" };
++static const char dmenufont[]       = "MesloLGS Nerd Font:size=10";
++
++#include "/home/fuzzbox/.cache/wal/colors-wal-dwm.h"
+ 
+ /* tagging */
+-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++static const char *tags[] = { "1 ", "2 ", "3 ", "4 ", "5 ", "6 ", "7 ", "8 ", "9 " };
++/* static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }; */
+ 
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+-	/* class      instance    title       tags mask     isfloating   monitor */
+-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ "URxvt",   NULL,     NULL,	       0,	  0,	      1,	   0,	     -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
+ };
+ 
+ /* layout(s) */
+-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
++static const float mfact     = 0.5; /* factor of master area size [0.05..0.95] */
+ static const int nmaster     = 1;    /* number of clients in master area */
+-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
++static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
++static const int attachdirection = 0;    /* 0 default, 1 above, 2 aside, 3 below, 4 bottom, 5 top */
++
++
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++
++#include "vanitygaps.c"
+ 
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+-	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
++	{ "[@]",      spiral },
++	{ "[\\]",     dwindle },
++	{ "H[]",      deck },
++	{ "TTT",      bstack },
++	{ "===",      bstackhoriz },
++	{ "HHH",      grid },
++	{ "###",      nrowgrid },
++	{ "---",      horizgrid },
++	{ ":::",      gaplessgrid },
++	{ "|M|",      centeredmaster },
++	{ ">M>",      centeredfloatingmaster },
++	{ "><>",      NULL },    /* no layout function means floating behavior */
++	{ NULL,       NULL },
+ };
+ 
+ /* key definitions */
+-#define MODKEY Mod1Mask
++#define MODKEY Mod4Mask
+ #define TAGKEYS(KEY,TAG) \
+ 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+ 
++#include <X11/XF86keysym.h>
++
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+-static const char *termcmd[]  = { "st", NULL };
++static const char *dmenucmd[]   = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-z", "800", "-p", "Run", NULL };
++static const char *dmenuwdcmd[] = { "dmenu-show-opened-windows", NULL };
++static const char *dmenucpcmd[] = { "clipmenu", "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-p", "Copy", NULL };
++static const char *dmenustcmd[] = { "dmenu-stop", NULL };
++static const char *termcmd[]    = { "urxvt", NULL };
+ 
+ static Key keys[] = {
+-	/* modifier                     key        function        argument */
+-	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+-	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+-	{ MODKEY,                       XK_b,      togglebar,      {0} },
+-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+-	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+-	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+-	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+-	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+-	{ MODKEY,                       XK_Return, zoom,           {0} },
+-	{ MODKEY,                       XK_Tab,    view,           {0} },
+-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+-	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
+-	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+-	{ MODKEY,                       XK_space,  setlayout,      {0} },
+-	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+-	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+-	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+-	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+-	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+-	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+-	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+-	TAGKEYS(                        XK_1,                      0)
+-	TAGKEYS(                        XK_2,                      1)
+-	TAGKEYS(                        XK_3,                      2)
+-	TAGKEYS(                        XK_4,                      3)
+-	TAGKEYS(                        XK_5,                      4)
+-	TAGKEYS(                        XK_6,                      5)
+-	TAGKEYS(                        XK_7,                      6)
+-	TAGKEYS(                        XK_8,                      7)
+-	TAGKEYS(                        XK_9,                      8)
+-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
++	/* modifier                     key        function          argument */
++	{ MODKEY,                       XK_d,      spawn,            {.v = dmenucmd } },
++	{ MODKEY,			XK_w,	   spawn, 	     {.v = dmenuwdcmd } },
++	{ MODKEY,			XK_c,	   spawn,	     {.v = dmenucpcmd } },
++	{ MODKEY,	                XK_Return, spawn,            {.v = termcmd } },
++	{ MODKEY|ShiftMask,		XK_h,	   spawn,	     {.v = dmenustcmd } },
++	{ MODKEY,                       XK_b,      togglebar,        {0} },
++	{ MODKEY,                       XK_k, 	   focusstack,       {.i = +1 } },
++	{ MODKEY,                       XK_j,      focusstack,       {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_k,      pushdown,         {0} },
++	{ MODKEY|ShiftMask,             XK_j,      pushup,           {0} },
++	{ MODKEY,                       XK_i,      incnmaster,       {.i = +1 } },
++	{ MODKEY,                       XK_o,      incnmaster,       {.i = -1 } },
++	{ MODKEY,                       XK_h,      setmfact,         {.f = -0.05} },
++	{ MODKEY,                       XK_l,      setmfact,         {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_Return, zoom,             {0} },
++	{ MODKEY|Mod1Mask,              XK_u,      incrgaps,         {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_u,      incrgaps,         {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_i,      incrigaps,        {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_i,      incrigaps,        {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_o,      incrogaps,        {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_o,      incrogaps,        {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_6,      incrihgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_6,      incrihgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_7,      incrivgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_7,      incrivgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_8,      incrohgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_8,      incrohgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_9,      incrovgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_9,      incrovgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_0,      togglegaps,       {0} }, 
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_0,      defaultgaps,      {0} },
++	{ MODKEY,                       XK_Tab,    view,             {0} },
++	{ MODKEY|ControlMask,           XK_Right,  shiftviewclients, { .i = +1 } },
++	{ MODKEY|ControlMask,           XK_Left,   shiftviewclients, { .i = -1 } },
++	{ MODKEY|ShiftMask,             XK_a,      killclient,       {0} },
++	{ MODKEY,                       XK_t,      setlayout,        {.v = &layouts[0]} },
++	{ MODKEY,			XK_g,	   setlayout,	     {.v = &layouts[11]} },
++	{ MODKEY,                       XK_f,      setlayout,        {.v = &layouts[1]} },
++	{ MODKEY,                       XK_m,      setlayout,        {.v = &layouts[2]} },
++	{ MODKEY,                       XK_r,      setlayout,        {.v = &layouts[7]} },
++	{ MODKEY,                       XK_space,  setlayout,        {0} },
++	{ MODKEY|ShiftMask,             XK_space,  togglefloating,   {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,    {0} },
++	{ MODKEY,                       XK_0,      view,             {.ui = ~0 } },
++	{ MODKEY|ShiftMask,             XK_0,      tag,              {.ui = ~0 } },
++	{ MODKEY,                       XK_Left,   focusmon,         {.i = -1 } },
++	{ MODKEY,                       XK_Right,  focusmon,         {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_Left,   tagmon,           {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_Right,  tagmon,           {.i = +1 } },
++	TAGKEYS(                        XK_ampersand,                0)
++	TAGKEYS(                        XK_eacute,                   1)
++	TAGKEYS(                        XK_quotedbl,                 2)
++	TAGKEYS(                        XK_apostrophe,               3)
++	TAGKEYS(                        XK_parenleft,                4)
++	TAGKEYS(                        XK_minus,                    5)
++	TAGKEYS(                        XK_egrave,                   6)
++	TAGKEYS(                        XK_underscore,               7)
++	TAGKEYS(                        XK_ccedilla,                 8)
++	{ MODKEY|ShiftMask,             XK_e,      quit,             {0} },
++	{ MODKEY|ControlMask|ShiftMask, XK_e,      quit,             {1} },
++	{ 0, XF86XK_MonBrightnessDown,  	   spawn,	     SHCMD("thinkpad-backlight down ; kill -39 $(pidof dwmblocks)") },
++	{ 0, XF86XK_MonBrightnessUp,    	   spawn,	     SHCMD("thinkpad-backlight up ; kill -39 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioRaiseVolume,   	   spawn,	     SHCMD("setvolume up ; kill -45 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioLowerVolume,   	   spawn,	     SHCMD("setvolume down ; kill -45 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioMute,   	   	   spawn,	     SHCMD("pactl set-sink-mute 0 toggle ; kill -45 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioMicMute,       	   spawn,	     SHCMD("pactl set-source-mute 1 toggle") },
++	{ 0, XK_Caps_Lock,		   	   spawn,	     SHCMD("kill -40 $(pidof dwmblocks)") },
++	{ 0, XK_Print,		   		   spawn,	     SHCMD("scrot -e 'mv $f ~/Images/Screenshots' && sleep 2 && notify-send Screenshot!!!") },
++	{ MODKEY|ShiftMask,		XK_b,	   spawn,	     SHCMD("firefox") },			
++	{ MODKEY|ShiftMask,		XK_n,	   spawn,	     SHCMD("start-ncmpcpp") },			
+ };
+ 
+ /* button definitions */
+diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.h" ./config.h
+--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.h"	1970-01-01 01:00:00.000000000 +0100
++++ ./config.h	2021-01-15 01:47:47.198187672 +0100
+@@ -0,0 +1,178 @@
++/* See LICENSE file for copyright and license details. */
++
++/* appearance */
++static const unsigned int borderpx  = 1;        /* border pixel of windows */
++static const unsigned int snap      = 32;       /* snap pixel */
++static const int swallowfloating    = 1;        /* 1 means swallow floating windows by default */
++static const unsigned int gappih    = 30;       /* horiz inner gap between windows */
++static const unsigned int gappiv    = 30;       /* vert inner gap between windows */
++static const unsigned int gappoh    = 30;       /* horiz outer gap between windows and screen edge */
++static const unsigned int gappov    = 30;       /* vert outer gap between windows and screen edge */
++static       int smartgaps          = 1;        /* 1 means no outer gap when there is only one window */
++static const int showbar            = 1;        /* 0 means no bar */
++static const int topbar             = 0;        /* 0 means bottom bar */
++static const int user_bh            = 32;        /* 0 means that dwm will calculate bar height, >= 1 means dwm will user_bh as bar height */
++static const char *fonts[]          = { "MesloLGS Nerd Font:size=10" };
++static const char dmenufont[]       = "MesloLGS Nerd Font:size=10";
++
++#include "/home/fuzzbox/.cache/wal/colors-wal-dwm.h"
++
++/* tagging */
++static const char *tags[] = { "1 ", "2 ", "3 ", "4 ", "5 ", "6 ", "7 ", "8 ", "9 " };
++/* static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }; */
++
++static const Rule rules[] = {
++	/* xprop(1):
++	 *	WM_CLASS(STRING) = instance, class
++	 *	WM_NAME(STRING) = title
++	 */
++	/* class     instance  title           tags mask  isfloating  isterminal  noswallow  monitor */
++	{ "Gimp",    NULL,     NULL,           0,         1,          0,           0,        -1 },
++	{ "Firefox", NULL,     NULL,           1 << 8,    0,          0,          -1,        -1 },
++	{ "St",      NULL,     NULL,           0,         0,          1,           0,        -1 },
++	{ "URxvt",   NULL,     NULL,	       0,	  0,	      1,	   0,	     -1 },
++	{ NULL,      NULL,     "Event Tester", 0,         0,          0,           1,        -1 }, /* xev */
++};
++
++/* layout(s) */
++static const float mfact     = 0.5; /* factor of master area size [0.05..0.95] */
++static const int nmaster     = 1;    /* number of clients in master area */
++static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
++static const int attachdirection = 0;    /* 0 default, 1 above, 2 aside, 3 below, 4 bottom, 5 top */
++
++
++#define FORCE_VSPLIT 1  /* nrowgrid layout: force two clients to always split vertically */
++
++#include "vanitygaps.c"
++
++static const Layout layouts[] = {
++	/* symbol     arrange function */
++	{ "[]=",      tile },    /* first entry is default */
++	{ "[M]",      monocle },
++	{ "[@]",      spiral },
++	{ "[\\]",     dwindle },
++	{ "H[]",      deck },
++	{ "TTT",      bstack },
++	{ "===",      bstackhoriz },
++	{ "HHH",      grid },
++	{ "###",      nrowgrid },
++	{ "---",      horizgrid },
++	{ ":::",      gaplessgrid },
++	{ "|M|",      centeredmaster },
++	{ ">M>",      centeredfloatingmaster },
++	{ "><>",      NULL },    /* no layout function means floating behavior */
++	{ NULL,       NULL },
++};
++
++/* key definitions */
++#define MODKEY Mod4Mask
++#define TAGKEYS(KEY,TAG) \
++	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
++	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
++	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
++	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++
++#include <X11/XF86keysym.h>
++
++/* helper for spawning shell commands in the pre dwm-5.0 fashion */
++#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
++
++/* commands */
++static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
++static const char *dmenucmd[]   = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-z", "800", "-p", "Run", NULL };
++static const char *dmenuwdcmd[] = { "dmenu-show-opened-windows", NULL };
++static const char *dmenucpcmd[] = { "clipmenu", "-fn", dmenufont, "-nb", norm_bg, "-nf", norm_fg, "-sb", sel_bg, "-sf", sel_fg, "-c", "-bw", "1", "-l", "5", "-p", "Copy", NULL };
++static const char *dmenustcmd[] = { "dmenu-stop", NULL };
++static const char *termcmd[]    = { "urxvt", NULL };
++
++static Key keys[] = {
++	/* modifier                     key        function          argument */
++	{ MODKEY,                       XK_d,      spawn,            {.v = dmenucmd } },
++	{ MODKEY,			XK_w,	   spawn, 	     {.v = dmenuwdcmd } },
++	{ MODKEY,			XK_c,	   spawn,	     {.v = dmenucpcmd } },
++	{ MODKEY,	                XK_Return, spawn,            {.v = termcmd } },
++	{ MODKEY|ShiftMask,		XK_h,	   spawn,	     {.v = dmenustcmd } },
++	{ MODKEY,                       XK_b,      togglebar,        {0} },
++	{ MODKEY,                       XK_k, 	   focusstack,       {.i = +1 } },
++	{ MODKEY,                       XK_j,      focusstack,       {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_k,      pushdown,         {0} },
++	{ MODKEY|ShiftMask,             XK_j,      pushup,           {0} },
++	{ MODKEY,                       XK_i,      incnmaster,       {.i = +1 } },
++	{ MODKEY,                       XK_o,      incnmaster,       {.i = -1 } },
++	{ MODKEY,                       XK_h,      setmfact,         {.f = -0.05} },
++	{ MODKEY,                       XK_l,      setmfact,         {.f = +0.05} },
++	{ MODKEY|ShiftMask,             XK_Return, zoom,             {0} },
++	{ MODKEY|Mod1Mask,              XK_u,      incrgaps,         {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_u,      incrgaps,         {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_i,      incrigaps,        {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_i,      incrigaps,        {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_o,      incrogaps,        {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_o,      incrogaps,        {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_6,      incrihgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_6,      incrihgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_7,      incrivgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_7,      incrivgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_8,      incrohgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_8,      incrohgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_9,      incrovgaps,       {.i = +1 } },
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_9,      incrovgaps,       {.i = -1 } },
++	{ MODKEY|Mod1Mask,              XK_0,      togglegaps,       {0} }, 
++	{ MODKEY|Mod1Mask|ShiftMask,    XK_0,      defaultgaps,      {0} },
++	{ MODKEY,                       XK_Tab,    view,             {0} },
++	{ MODKEY|ControlMask,           XK_Right,  shiftviewclients, { .i = +1 } },
++	{ MODKEY|ControlMask,           XK_Left,   shiftviewclients, { .i = -1 } },
++	{ MODKEY|ShiftMask,             XK_a,      killclient,       {0} },
++	{ MODKEY,                       XK_t,      setlayout,        {.v = &layouts[0]} },
++	{ MODKEY,			XK_g,	   setlayout,	     {.v = &layouts[11]} },
++	{ MODKEY,                       XK_f,      setlayout,        {.v = &layouts[1]} },
++	{ MODKEY,                       XK_m,      setlayout,        {.v = &layouts[2]} },
++	{ MODKEY,                       XK_r,      setlayout,        {.v = &layouts[7]} },
++	{ MODKEY,                       XK_space,  setlayout,        {0} },
++	{ MODKEY|ShiftMask,             XK_space,  togglefloating,   {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,    {0} },
++	{ MODKEY,                       XK_0,      view,             {.ui = ~0 } },
++	{ MODKEY|ShiftMask,             XK_0,      tag,              {.ui = ~0 } },
++	{ MODKEY,                       XK_Left,   focusmon,         {.i = -1 } },
++	{ MODKEY,                       XK_Right,  focusmon,         {.i = +1 } },
++	{ MODKEY|ShiftMask,             XK_Left,   tagmon,           {.i = -1 } },
++	{ MODKEY|ShiftMask,             XK_Right,  tagmon,           {.i = +1 } },
++	TAGKEYS(                        XK_ampersand,                0)
++	TAGKEYS(                        XK_eacute,                   1)
++	TAGKEYS(                        XK_quotedbl,                 2)
++	TAGKEYS(                        XK_apostrophe,               3)
++	TAGKEYS(                        XK_parenleft,                4)
++	TAGKEYS(                        XK_minus,                    5)
++	TAGKEYS(                        XK_egrave,                   6)
++	TAGKEYS(                        XK_underscore,               7)
++	TAGKEYS(                        XK_ccedilla,                 8)
++	{ MODKEY|ShiftMask,             XK_e,      quit,             {0} },
++	{ MODKEY|ControlMask|ShiftMask, XK_e,      quit,             {1} },
++	{ 0, XF86XK_MonBrightnessDown,  	   spawn,	     SHCMD("thinkpad-backlight down ; kill -39 $(pidof dwmblocks)") },
++	{ 0, XF86XK_MonBrightnessUp,    	   spawn,	     SHCMD("thinkpad-backlight up ; kill -39 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioRaiseVolume,   	   spawn,	     SHCMD("setvolume up ; kill -45 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioLowerVolume,   	   spawn,	     SHCMD("setvolume down ; kill -45 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioMute,   	   	   spawn,	     SHCMD("pactl set-sink-mute 0 toggle ; kill -45 $(pidof dwmblocks)") },
++	{ 0, XF86XK_AudioMicMute,       	   spawn,	     SHCMD("pactl set-source-mute 1 toggle") },
++	{ 0, XK_Caps_Lock,		   	   spawn,	     SHCMD("kill -40 $(pidof dwmblocks)") },
++	{ 0, XK_Print,		   		   spawn,	     SHCMD("scrot -e 'mv $f ~/Images/Screenshots' && sleep 2 && notify-send Screenshot!!!") },
++	{ MODKEY|ShiftMask,		XK_b,	   spawn,	     SHCMD("firefox") },			
++	{ MODKEY|ShiftMask,		XK_n,	   spawn,	     SHCMD("start-ncmpcpp") },			
++};
++
++/* button definitions */
++/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
++static Button buttons[] = {
++	/* click                event mask      button          function        argument */
++	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
++	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
++	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
++	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
++	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
++	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
++	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
++	{ ClkTagBar,            0,              Button1,        view,           {0} },
++	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
++	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
++	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
++};
++
+diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.mk" ./config.mk
+--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/config.mk"	2021-01-13 22:22:32.377160109 +0100
++++ ./config.mk	2021-01-14 12:01:27.645385019 +0100
+@@ -19,10 +19,11 @@ FREETYPELIBS = -lfontconfig -lXft
+ FREETYPEINC = /usr/include/freetype2
+ # OpenBSD (uncomment)
+ #FREETYPEINC = ${X11INC}/freetype2
++#KVMLIB = -lkvm
+ 
+ # includes and libs
+ INCS = -I${X11INC} -I${FREETYPEINC}
+-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} -lX11-xcb -lxcb -lxcb-res ${KVMLIB}
+ 
+ # flags
+ CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+Les fichiers binaires /home/fuzzbox/Téléchargements/dwm/drw.o et ./drw.o sont différents
+Les fichiers binaires /home/fuzzbox/Téléchargements/dwm/dwm et ./dwm sont différents
+diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.1" ./dwm.1
+--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.1"	2021-01-13 22:22:32.377160109 +0100
++++ ./dwm.1	2021-01-14 12:01:27.645385019 +0100
+@@ -30,6 +30,14 @@ top left corner.  The tags which are app
+ indicated with an empty square in the top left corner.
+ .P
+ dwm draws a small border around windows to indicate the focus state.
++.P
++On start, dwm can start additional programs that may be specified in two special
++shell scripts (see the FILES section below), autostart_blocking.sh and
++autostart.sh.  The former is executed first and dwm will wait for its
++termination before starting.  The latter is executed in the background before
++dwm enters its handler loop.
++.P
++Either of these files may be omitted.
+ .SH OPTIONS
+ .TP
+ .B \-v
+@@ -142,6 +150,9 @@ Add/remove all windows with nth tag to/f
+ .TP
+ .B Mod1\-Shift\-q
+ Quit dwm.
++.TP
++.B Mod1\-Control\-Shift\-q
++Restart dwm.
+ .SS Mouse commands
+ .TP
+ .B Mod1\-Button1
+@@ -152,9 +163,31 @@ Toggles focused window between floating
+ .TP
+ .B Mod1\-Button3
+ Resize focused window while dragging. Tiled windows will be toggled to the floating state.
++.SH FILES
++The files containing programs to be started along with dwm are searched for in
++the following directories:
++.IP "1. $XDG_DATA_HOME/dwm"
++.IP "2. $HOME/.local/share/dwm"
++.IP "3. $HOME/.dwm"
++.P
++The first existing directory is scanned for any of the autostart files below.
++.TP 15
++autostart.sh
++This file is started as a shell background process before dwm enters its handler
++loop.
++.TP 15
++autostart_blocking.sh
++This file is started before any autostart.sh; dwm waits for its termination.
+ .SH CUSTOMIZATION
+ dwm is customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
++.SH SIGNALS
++.TP
++.B SIGHUP - 1
++Restart the dwm process.
++.TP
++.B SIGTERM - 15
++Cleanly terminate the dwm process.
+ .SH SEE ALSO
+ .BR dmenu (1),
+ .BR st (1)
+diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c" ./dwm.c
+--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c"	2021-01-13 22:22:32.380493442 +0100
++++ ./dwm.c	2021-01-15 01:47:32.278188444 +0100
+@@ -29,6 +29,7 @@
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+@@ -40,6 +41,12 @@
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
+ 
+ #include "drw.h"
+ #include "util.h"
+@@ -49,7 +56,8 @@
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
++#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
++#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+@@ -59,7 +67,7 @@
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+-enum { SchemeNorm, SchemeSel }; /* color schemes */
++enum { SchemeNorm, SchemeSel, SchemeUrg }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+@@ -92,9 +100,11 @@ struct Client {
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
++	pid_t pid;
+ 	Client *next;
+ 	Client *snext;
++	Client *swallowing;
+ 	Monitor *mon;
+ 	Window win;
+ };
+@@ -111,6 +121,7 @@ typedef struct {
+ 	void (*arrange)(Monitor *);
+ } Layout;
+ 
++typedef struct Pertag Pertag;
+ struct Monitor {
+ 	char ltsymbol[16];
+ 	float mfact;
+@@ -119,6 +130,10 @@ struct Monitor {
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+@@ -130,6 +145,7 @@ struct Monitor {
+ 	Monitor *next;
+ 	Window barwin;
+ 	const Layout *lt[2];
++	Pertag *pertag;
+ };
+ 
+ typedef struct {
+@@ -138,6 +154,8 @@ typedef struct {
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
++	int isterminal;
++	int noswallow;
+ 	int monitor;
+ } Rule;
+ 
+@@ -147,6 +165,11 @@ static int applysizehints(Client *c, int
+ static void arrange(Monitor *m);
+ static void arrangemon(Monitor *m);
+ static void attach(Client *c);
++static void attachabove(Client *c);
++static void attachaside(Client *c);
++static void attachbelow(Client *c);
++static void attachbottom(Client *c);
++static void attachtop(Client *c);
+ static void attachstack(Client *c);
+ static void buttonpress(XEvent *e);
+ static void checkotherwm(void);
+@@ -163,6 +186,7 @@ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+@@ -184,9 +208,13 @@ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+ static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
++static Client *nexttagged(Client *c);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
++static Client *prevtiled(Client *c);
+ static void propertynotify(XEvent *e);
++static void pushdown(const Arg *arg);
++static void pushup(const Arg *arg);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+ static void resize(Client *c, int x, int y, int w, int h, int interact);
+@@ -194,6 +222,7 @@ static void resizeclient(Client *c, int
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
++static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+@@ -204,14 +233,17 @@ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
++static void shiftviewclients(const Arg *arg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
++static void sighup(int unused);
++static void sigterm(int unused);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+-static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglefullscr(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -235,9 +267,19 @@ static int xerrordummy(Display *dpy, XEr
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ 
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
++
+ /* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
+-static char stext[256];
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
++static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+@@ -261,6 +303,7 @@ static void (*handler[LASTEvent]) (XEven
+ 	[UnmapNotify] = unmapnotify
+ };
+ static Atom wmatom[WMLast], netatom[NetLast];
++static int restart = 0;
+ static int running = 1;
+ static Cur *cursor[CurLast];
+ static Clr **scheme;
+@@ -269,9 +312,20 @@ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
++static xcb_connection_t *xcon;
++
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
++struct Pertag {
++	unsigned int curtag, prevtag; /* current and previous tag */
++	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
++	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
++	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
++	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
++	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
++};
++
+ /* compile-time check if all tags fit into an unsigned int bit array. */
+ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+ 
+@@ -298,6 +352,8 @@ applyrules(Client *c)
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+@@ -408,6 +464,73 @@ attach(Client *c)
+ }
+ 
+ void
++attachabove(Client *c)
++{
++	if (c->mon->sel == NULL || c->mon->sel == c->mon->clients || c->mon->sel->isfloating) {
++		attach(c);
++		return;
++	}
++
++	Client *at;
++	for (at = c->mon->clients; at->next != c->mon->sel; at = at->next);
++	c->next = at->next;
++	at->next = c;
++}
++
++void
++attachaside(Client *c) {
++	Client *at = nexttagged(c);
++	if(!at) {
++		attach(c);
++		return;
++		}
++	c->next = at->next;
++	at->next = c;
++}
++
++void
++attachbelow(Client *c)
++{
++	if(c->mon->sel == NULL || c->mon->sel == c || c->mon->sel->isfloating) {
++		attach(c);
++		return;
++	}
++	c->next = c->mon->sel->next;
++	c->mon->sel->next = c;
++}
++ 
++void
++attachbottom(Client *c)
++{
++	Client *below = c->mon->clients;
++	for (; below && below->next; below = below->next);
++	c->next = NULL;
++	if (below)
++		below->next = c;
++	else
++		c->mon->clients = c;
++}
++
++void
++attachtop(Client *c)
++{
++	int n;
++	Monitor *m = selmon;
++	Client *below;
++
++	for (n = 1, below = c->mon->clients;
++		below && below->next && (below->isfloating || !ISVISIBLEONTAG(below, c->tags) || n != m->nmaster);
++		n = below->isfloating || !ISVISIBLEONTAG(below, c->tags) ? n + 0 : n + 1, below = below->next);
++	c->next = NULL;
++	if (below) {
++		c->next = below->next;
++		below->next = c;
++	}
++	else
++		c->mon->clients = c;
++}
++
++void
+ attachstack(Client *c)
+ {
+ 	c->snext = c->mon->stack;
+@@ -415,6 +538,53 @@ attachstack(Client *c)
+ }
+ 
+ void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
++void
+ buttonpress(XEvent *e)
+ {
+ 	unsigned int i, x, click;
+@@ -485,7 +655,7 @@ cleanup(void)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+-	for (i = 0; i < LENGTH(colors); i++)
++	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	XDestroyWindow(dpy, wmcheckwin);
+ 	drw_free(drw);
+@@ -515,6 +685,7 @@ clientmessage(XEvent *e)
+ {
+ 	XClientMessageEvent *cme = &e->xclient;
+ 	Client *c = wintoclient(cme->window);
++	unsigned int i;
+ 
+ 	if (!c)
+ 		return;
+@@ -524,8 +695,14 @@ clientmessage(XEvent *e)
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+-		if (c != selmon->sel && !c->isurgent)
+-			seturgent(c, 1);
++		for (i = 0; i < LENGTH(tags) && !((1 << i) & c->tags); i++);
++		if (i < LENGTH(tags)) {
++			const Arg a = {.ui = 1 << i};
++			selmon = c->mon;
++			view(&a);
++			focus(c);
++			restack(selmon);
++		}
+ 	}
+ }
+ 
+@@ -632,6 +809,7 @@ Monitor *
+ createmon(void)
+ {
+ 	Monitor *m;
++	unsigned int i;
+ 
+ 	m = ecalloc(1, sizeof(Monitor));
+ 	m->tagset[0] = m->tagset[1] = 1;
+@@ -639,9 +817,27 @@ createmon(void)
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++	m->pertag = ecalloc(1, sizeof(Pertag));
++	m->pertag->curtag = m->pertag->prevtag = 1;
++
++	for (i = 0; i <= LENGTH(tags); i++) {
++		m->pertag->nmasters[i] = m->nmaster;
++		m->pertag->mfacts[i] = m->mfact;
++
++		m->pertag->ltidxs[i][0] = m->lt[0];
++		m->pertag->ltidxs[i][1] = m->lt[1];
++		m->pertag->sellts[i] = m->sellt;
++
++		m->pertag->showbars[i] = m->showbar;
++	}
++
+ 	return m;
+ }
+ 
+@@ -653,6 +849,9 @@ destroynotify(XEvent *e)
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
+ }
+ 
+ void
+@@ -693,6 +892,114 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -704,9 +1011,7 @@ drawbar(Monitor *m)
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+-		drw_setscheme(drw, scheme[SchemeNorm]);
+-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
++		tw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+@@ -967,7 +1272,7 @@ grabkeys(void)
+ void
+ incnmaster(const Arg *arg)
+ {
+-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+ 	arrange(selmon);
+ }
+ 
+@@ -1018,12 +1323,13 @@ killclient(const Arg *arg)
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+-	Client *c, *t = NULL;
++	Client *c, *t = NULL, *term = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
++	c->pid = winpid(w);
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+@@ -1038,6 +1344,7 @@ manage(Window w, XWindowAttributes *wa)
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
++		term = termforwin(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
+@@ -1063,7 +1370,25 @@ manage(Window w, XWindowAttributes *wa)
+ 		c->isfloating = c->oldstate = trans != None || c->isfixed;
+ 	if (c->isfloating)
+ 		XRaiseWindow(dpy, c->win);
+-	attach(c);
++	switch(attachdirection){
++		case 1:
++			attachabove(c);
++			break;
++		case 2:
++			attachaside(c);
++			break;
++		case 3:
++			attachbelow(c);
++			break;
++		case 4:
++			attachbottom(c);
++			break;
++		case 5:
++			attachtop(c);
++			break;
++		default:
++			attach(c);
++	}
+ 	attachstack(c);
+ 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
+ 		(unsigned char *) &(c->win), 1);
+@@ -1074,6 +1399,8 @@ manage(Window w, XWindowAttributes *wa)
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
+ 	focus(NULL);
+ }
+ 
+@@ -1194,6 +1521,16 @@ movemouse(const Arg *arg)
+ }
+ 
+ Client *
++nexttagged(Client *c) {
++	Client *walked = c->mon->clients;
++	for(;
++		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
++		walked = walked->next
++	);
++	return walked;
++}
++
++Client *
+ nexttiled(Client *c)
+ {
+ 	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
+@@ -1209,6 +1546,16 @@ pop(Client *c)
+ 	arrange(c->mon);
+ }
+ 
++Client *
++prevtiled(Client *c) {
++	Client *p, *r;
++
++	for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
++		if(!p->isfloating && ISVISIBLE(p))
++			r = p;
++	return r;
++}
++
+ void
+ propertynotify(XEvent *e)
+ {
+@@ -1247,8 +1594,40 @@ propertynotify(XEvent *e)
+ }
+ 
+ void
++pushdown(const Arg *arg) {
++	Client *sel = selmon->sel, *c;
++
++	if(!sel || sel->isfloating || sel == nexttiled(selmon->clients))
++		return;
++	if((c = nexttiled(sel->next))) {
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	focus(sel);
++	arrange(selmon);
++}
++
++void
++pushup(const Arg *arg) {
++	Client *sel = selmon->sel, *c;
++
++	if(!sel || sel->isfloating)
++		return;
++	if((c = prevtiled(sel)) && c != nexttiled(selmon->clients)) {
++		detach(sel);
++		sel->next = c;
++		for(c = selmon->clients; c->next != sel->next; c = c->next);
++		c->next = sel;
++	}
++	focus(sel);
++	arrange(selmon);
++}
++
++void
+ quit(const Arg *arg)
+ {
++	if(arg->i) restart = 1;
+ 	running = 0;
+ }
+ 
+@@ -1283,6 +1662,14 @@ resizeclient(Client *c, int x, int y, in
+ 	c->oldw = c->w; c->w = wc.width = w;
+ 	c->oldh = c->h; c->h = wc.height = h;
+ 	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating
++	    && NULL != c->mon->lt[c->mon->sellt]->arrange) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
+ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+ 	configure(c);
+ 	XSync(dpy, False);
+@@ -1382,6 +1769,83 @@ run(void)
+ }
+ 
+ void
++runautostart(void)
++{
++	char *pathpfx;
++	char *path;
++	char *xdgdatahome;
++	char *home;
++	struct stat sb;
++
++	if ((home = getenv("HOME")) == NULL)
++		/* this is almost impossible */
++		return;
++
++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++	 * otherwise use ~/.local/share/dwm as autostart script directory
++	 */
++	xdgdatahome = getenv("XDG_DATA_HOME");
++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++
++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	} else {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++		                     + strlen(dwmdir) + 3);
++
++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* check if the autostart script directory exists */
++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++		/* the XDG conformant path does not exist or is no directory
++		 * so we try ~/.dwm instead
++		 */
++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++		if(pathpfx_new == NULL) {
++			free(pathpfx);
++			return;
++		}
++   pathpfx = pathpfx_new;
++
++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* try the blocking script first */
++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(path);
++
++	/* now the non-blocking script */
++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(strcat(path, " &"));
++
++	free(pathpfx);
++	free(path);
++}
++
++void
+ scan(void)
+ {
+ 	unsigned int i, num;
+@@ -1418,7 +1882,25 @@ sendmon(Client *c, Monitor *m)
+ 	detachstack(c);
+ 	c->mon = m;
+ 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+-	attach(c);
++	switch(attachdirection){
++		case 1:
++			attachabove(c);
++			break;
++		case 2:
++			attachaside(c);
++			break;
++		case 3:
++			attachbelow(c);
++			break;
++		case 4:
++			attachbottom(c);
++			break;
++		case 5:
++			attachtop(c);
++			break;
++		default:
++			attach(c);
++	}
+ 	attachstack(c);
+ 	focus(NULL);
+ 	arrange(NULL);
+@@ -1502,9 +1984,9 @@ void
+ setlayout(const Arg *arg)
+ {
+ 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+-		selmon->sellt ^= 1;
++		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+ 	if (arg && arg->v)
+-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+ 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+ 	if (selmon->sel)
+ 		arrange(selmon);
+@@ -1523,7 +2005,7 @@ setmfact(const Arg *arg)
+ 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+ 	if (f < 0.05 || f > 0.95)
+ 		return;
+-	selmon->mfact = f;
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+ 	arrange(selmon);
+ }
+ 
+@@ -1537,6 +2019,9 @@ setup(void)
+ 	/* clean up any zombies immediately */
+ 	sigchld(0);
+ 
++	signal(SIGHUP, sighup);
++	signal(SIGTERM, sigterm);
++
+ 	/* init screen */
+ 	screen = DefaultScreen(dpy);
+ 	sw = DisplayWidth(dpy, screen);
+@@ -1546,7 +2031,7 @@ setup(void)
+ 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+ 		die("no fonts could be loaded.");
+ 	lrpad = drw->fonts->h;
+-	bh = drw->fonts->h + 2;
++	bh = user_bh ? user_bh : drw->fonts->h + 2;
+ 	updategeom();
+ 	/* init atoms */
+ 	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
+@@ -1568,7 +2053,8 @@ setup(void)
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+-	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
+@@ -1612,6 +2098,46 @@ seturgent(Client *c, int urg)
+ }
+ 
+ void
++shiftviewclients(const Arg *arg)
++{
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++
++	for (c = selmon->clients; c; c = c->next)
++		#if SCRATCHPADS_PATCH
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++		#else
++		tagmask = tagmask | c->tags;
++		#endif // SCRATCHPADS_PATCH
++
++	#if SCRATCHPADS_PATCH
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++	#else
++	shifted.ui = selmon->tagset[selmon->seltags];
++	#endif // SCRATCHPADS_PATCH
++	if (arg->i > 0) // left circular shift
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			#if SCRATCHPADS_PATCH
++			shifted.ui &= ~SPTAGMASK;
++			#endif // SCRATCHPADS_PATCH
++		} while (tagmask && !(shifted.ui & tagmask));
++	else // right circular shift
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			#if SCRATCHPADS_PATCH
++			shifted.ui &= ~SPTAGMASK;
++			#endif // SCRATCHPADS_PATCH
++		} while (tagmask && !(shifted.ui & tagmask));
++
++	view(&shifted);
++}
++
++void
+ showhide(Client *c)
+ {
+ 	if (!c)
+@@ -1638,6 +2164,20 @@ sigchld(int unused)
+ }
+ 
+ void
++sighup(int unused)
++{
++	Arg a = {.i = 1};
++	quit(&a);
++}
++
++void
++sigterm(int unused)
++{
++	Arg a = {.i = 0};
++	quit(&a);
++}
++
++void
+ spawn(const Arg *arg)
+ {
+ 	if (arg->v == dmenucmd)
+@@ -1672,37 +2212,9 @@ tagmon(const Arg *arg)
+ }
+ 
+ void
+-tile(Monitor *m)
+-{
+-	unsigned int i, n, h, mw, my, ty;
+-	Client *c;
+-
+-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+-	if (n == 0)
+-		return;
+-
+-	if (n > m->nmaster)
+-		mw = m->nmaster ? m->ww * m->mfact : 0;
+-	else
+-		mw = m->ww;
+-	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+-		if (i < m->nmaster) {
+-			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+-			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (my + HEIGHT(c) < m->wh)
+-				my += HEIGHT(c);
+-		} else {
+-			h = (m->wh - ty) / (n - i);
+-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+-			if (ty + HEIGHT(c) < m->wh)
+-				ty += HEIGHT(c);
+-		}
+-}
+-
+-void
+ togglebar(const Arg *arg)
+ {
+-	selmon->showbar = !selmon->showbar;
++	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
+ 	updatebarpos(selmon);
+ 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+ 	arrange(selmon);
+@@ -1723,6 +2235,13 @@ togglefloating(const Arg *arg)
+ }
+ 
+ void
++togglefullscr(const Arg *arg)
++{
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++}
++
++void
+ toggletag(const Arg *arg)
+ {
+ 	unsigned int newtags;
+@@ -1741,9 +2260,33 @@ void
+ toggleview(const Arg *arg)
+ {
+ 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++	int i;
+ 
+ 	if (newtagset) {
+ 		selmon->tagset[selmon->seltags] = newtagset;
++
++		if (newtagset == ~0) {
++			selmon->pertag->prevtag = selmon->pertag->curtag;
++			selmon->pertag->curtag = 0;
++		}
++
++		/* test if the user did not select the same tag */
++		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
++			selmon->pertag->prevtag = selmon->pertag->curtag;
++			for (i = 0; !(newtagset & 1 << i); i++) ;
++			selmon->pertag->curtag = i + 1;
++		}
++
++		/* apply settings for this view */
++		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
++		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
++			togglebar(NULL);
++
+ 		focus(NULL);
+ 		arrange(selmon);
+ 	}
+@@ -1768,6 +2311,20 @@ unmanage(Client *c, int destroyed)
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+@@ -1782,9 +2339,12 @@ unmanage(Client *c, int destroyed)
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+-	focus(NULL);
+-	updateclientlist();
+-	arrange(m);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
+ }
+ 
+ void
+@@ -1900,7 +2460,25 @@ updategeom(void)
+ 					m->clients = c->next;
+ 					detachstack(c);
+ 					c->mon = mons;
+-					attach(c);
++					switch(attachdirection){
++					case 1:
++						attachabove(c);
++						break;
++					case 2:
++						attachaside(c);
++						break;
++					case 3:
++						attachbelow(c);
++						break;
++					case 4:
++						attachbottom(c);
++						break;
++					case 5:
++						attachtop(c);
++						break;
++					default:
++						attach(c);
++					}
+ 					attachstack(c);
+ 				}
+ 				if (m == selmon)
+@@ -2025,8 +2603,11 @@ updatewmhints(Client *c)
+ 		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
+ 			wmh->flags &= ~XUrgencyHint;
+ 			XSetWMHints(dpy, c->win, wmh);
+-		} else
++		} else {
+ 			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
++			if (c->isurgent)
++				XSetWindowBorder(dpy, c->win, scheme[SchemeUrg][ColBorder].pixel);
++		}
+ 		if (wmh->flags & InputHint)
+ 			c->neverfocus = !wmh->input;
+ 		else
+@@ -2038,15 +2619,171 @@ updatewmhints(Client *c)
+ void
+ view(const Arg *arg)
+ {
++	int i;
++	unsigned int tmptag;
++
+ 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+ 		return;
+ 	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
++	if (arg->ui & TAGMASK) {
+ 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++
++		if (arg->ui == ~0)
++			selmon->pertag->curtag = 0;
++		else {
++			for (i = 0; !(arg->ui & 1 << i); i++) ;
++			selmon->pertag->curtag = i + 1;
++		}
++	} else {
++		tmptag = selmon->pertag->prevtag;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++		selmon->pertag->curtag = tmptag;
++	}
++
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
++	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
++		togglebar(NULL);
++
+ 	focus(NULL);
+ 	arrange(selmon);
+ }
+ 
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
+ Client *
+ wintoclient(Window w)
+ {
+@@ -2138,14 +2875,18 @@ main(int argc, char *argv[])
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
+ 	checkotherwm();
+ 	setup();
+ #ifdef __OpenBSD__
+-	if (pledge("stdio rpath proc exec", NULL) == -1)
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
++	runautostart();
+ 	run();
++	if(restart) execvp(argv[0], argv);
+ 	cleanup();
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c.orig" ./dwm.c.orig
+--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/dwm.c.orig"	1970-01-01 01:00:00.000000000 +0100
++++ ./dwm.c.orig	2021-01-15 01:42:37.278203726 +0100
+@@ -0,0 +1,2817 @@
++/* See LICENSE file for copyright and license details.
++ *
++ * dynamic window manager is designed like any other X client as well. It is
++ * driven through handling X events. In contrast to other X clients, a window
++ * manager selects for SubstructureRedirectMask on the root window, to receive
++ * events about window (dis-)appearance. Only one X connection at a time is
++ * allowed to select for this event mask.
++ *
++ * The event handlers of dwm are organized in an array which is accessed
++ * whenever a new event has been fetched. This allows event dispatching
++ * in O(1) time.
++ *
++ * Each child of the root window is called a client, except windows which have
++ * set the override_redirect flag. Clients are organized in a linked client
++ * list on each monitor, the focus history is remembered through a stack list
++ * on each monitor. Each client contains a bit array to indicate the tags of a
++ * client.
++ *
++ * Keys and tagging rules are organized as arrays and defined in config.h.
++ *
++ * To understand everything else, start reading main().
++ */
++#include <errno.h>
++#include <locale.h>
++#include <signal.h>
++#include <stdarg.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <unistd.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <sys/wait.h>
++#include <X11/cursorfont.h>
++#include <X11/keysym.h>
++#include <X11/Xatom.h>
++#include <X11/Xlib.h>
++#include <X11/Xproto.h>
++#include <X11/Xutil.h>
++#ifdef XINERAMA
++#include <X11/extensions/Xinerama.h>
++#endif /* XINERAMA */
++#include <X11/Xft/Xft.h>
++#include <X11/Xlib-xcb.h>
++#include <xcb/res.h>
++#ifdef __OpenBSD__
++#include <sys/sysctl.h>
++#include <kvm.h>
++#endif /* __OpenBSD */
++
++#include "drw.h"
++#include "util.h"
++
++/* macros */
++#define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
++#define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
++#define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
++                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
++#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
++#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
++#define LENGTH(X)               (sizeof X / sizeof X[0])
++#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
++#define WIDTH(X)                ((X)->w + 2 * (X)->bw)
++#define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
++#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
++#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
++
++/* enums */
++enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
++enum { SchemeNorm, SchemeSel, SchemeUrg }; /* color schemes */
++enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
++       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
++       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
++enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
++enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
++       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
++
++typedef union {
++	int i;
++	unsigned int ui;
++	float f;
++	const void *v;
++} Arg;
++
++typedef struct {
++	unsigned int click;
++	unsigned int mask;
++	unsigned int button;
++	void (*func)(const Arg *arg);
++	const Arg arg;
++} Button;
++
++typedef struct Monitor Monitor;
++typedef struct Client Client;
++struct Client {
++	char name[256];
++	float mina, maxa;
++	int x, y, w, h;
++	int oldx, oldy, oldw, oldh;
++	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
++	int bw, oldbw;
++	unsigned int tags;
++	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen, isterminal, noswallow;
++	pid_t pid;
++	Client *next;
++	Client *snext;
++	Client *swallowing;
++	Monitor *mon;
++	Window win;
++};
++
++typedef struct {
++	unsigned int mod;
++	KeySym keysym;
++	void (*func)(const Arg *);
++	const Arg arg;
++} Key;
++
++typedef struct {
++	const char *symbol;
++	void (*arrange)(Monitor *);
++} Layout;
++
++struct Monitor {
++	char ltsymbol[16];
++	float mfact;
++	int nmaster;
++	int num;
++	int by;               /* bar geometry */
++	int mx, my, mw, mh;   /* screen size */
++	int wx, wy, ww, wh;   /* window area  */
++	int gappih;           /* horizontal gap between windows */
++	int gappiv;           /* vertical gap between windows */
++	int gappoh;           /* horizontal outer gaps */
++	int gappov;           /* vertical outer gaps */
++	unsigned int seltags;
++	unsigned int sellt;
++	unsigned int tagset[2];
++	int showbar;
++	int topbar;
++	Client *clients;
++	Client *sel;
++	Client *stack;
++	Monitor *next;
++	Window barwin;
++	const Layout *lt[2];
++};
++
++typedef struct {
++	const char *class;
++	const char *instance;
++	const char *title;
++	unsigned int tags;
++	int isfloating;
++	int isterminal;
++	int noswallow;
++	int monitor;
++} Rule;
++
++/* function declarations */
++static void applyrules(Client *c);
++static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
++static void arrange(Monitor *m);
++static void arrangemon(Monitor *m);
++static void attach(Client *c);
++static void attachabove(Client *c);
++static void attachaside(Client *c);
++static void attachbelow(Client *c);
++static void attachbottom(Client *c);
++static void attachtop(Client *c);
++static void attachstack(Client *c);
++static void buttonpress(XEvent *e);
++static void checkotherwm(void);
++static void cleanup(void);
++static void cleanupmon(Monitor *mon);
++static void clientmessage(XEvent *e);
++static void configure(Client *c);
++static void configurenotify(XEvent *e);
++static void configurerequest(XEvent *e);
++static Monitor *createmon(void);
++static void destroynotify(XEvent *e);
++static void detach(Client *c);
++static void detachstack(Client *c);
++static Monitor *dirtomon(int dir);
++static void drawbar(Monitor *m);
++static void drawbars(void);
++static int drawstatusbar(Monitor *m, int bh, char* text);
++static void enternotify(XEvent *e);
++static void expose(XEvent *e);
++static void focus(Client *c);
++static void focusin(XEvent *e);
++static void focusmon(const Arg *arg);
++static void focusstack(const Arg *arg);
++static Atom getatomprop(Client *c, Atom prop);
++static int getrootptr(int *x, int *y);
++static long getstate(Window w);
++static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
++static void grabbuttons(Client *c, int focused);
++static void grabkeys(void);
++static void incnmaster(const Arg *arg);
++static void keypress(XEvent *e);
++static void killclient(const Arg *arg);
++static void manage(Window w, XWindowAttributes *wa);
++static void mappingnotify(XEvent *e);
++static void maprequest(XEvent *e);
++static void monocle(Monitor *m);
++static void motionnotify(XEvent *e);
++static void movemouse(const Arg *arg);
++static Client *nexttagged(Client *c);
++static Client *nexttiled(Client *c);
++static void pop(Client *);
++static Client *prevtiled(Client *c);
++static void propertynotify(XEvent *e);
++static void pushdown(const Arg *arg);
++static void pushup(const Arg *arg);
++static void quit(const Arg *arg);
++static Monitor *recttomon(int x, int y, int w, int h);
++static void resize(Client *c, int x, int y, int w, int h, int interact);
++static void resizeclient(Client *c, int x, int y, int w, int h);
++static void resizemouse(const Arg *arg);
++static void restack(Monitor *m);
++static void run(void);
++static void runautostart(void);
++static void scan(void);
++static int sendevent(Client *c, Atom proto);
++static void sendmon(Client *c, Monitor *m);
++static void setclientstate(Client *c, long state);
++static void setfocus(Client *c);
++static void setfullscreen(Client *c, int fullscreen);
++static void setlayout(const Arg *arg);
++static void setmfact(const Arg *arg);
++static void setup(void);
++static void seturgent(Client *c, int urg);
++static void shiftviewclients(const Arg *arg);
++static void showhide(Client *c);
++static void sigchld(int unused);
++static void sighup(int unused);
++static void sigterm(int unused);
++static void spawn(const Arg *arg);
++static void tag(const Arg *arg);
++static void tagmon(const Arg *arg);
++static void togglebar(const Arg *arg);
++static void togglefloating(const Arg *arg);
++static void togglefullscr(const Arg *arg);
++static void toggletag(const Arg *arg);
++static void toggleview(const Arg *arg);
++static void unfocus(Client *c, int setfocus);
++static void unmanage(Client *c, int destroyed);
++static void unmapnotify(XEvent *e);
++static void updatebarpos(Monitor *m);
++static void updatebars(void);
++static void updateclientlist(void);
++static int updategeom(void);
++static void updatenumlockmask(void);
++static void updatesizehints(Client *c);
++static void updatestatus(void);
++static void updatetitle(Client *c);
++static void updatewindowtype(Client *c);
++static void updatewmhints(Client *c);
++static void view(const Arg *arg);
++static Client *wintoclient(Window w);
++static Monitor *wintomon(Window w);
++static int xerror(Display *dpy, XErrorEvent *ee);
++static int xerrordummy(Display *dpy, XErrorEvent *ee);
++static int xerrorstart(Display *dpy, XErrorEvent *ee);
++static void zoom(const Arg *arg);
++
++static pid_t getparentprocess(pid_t p);
++static int isdescprocess(pid_t p, pid_t c);
++static Client *swallowingclient(Window w);
++static Client *termforwin(const Client *c);
++static pid_t winpid(Window w);
++
++/* variables */
++static const char autostartblocksh[] = "autostart_blocking.sh";
++static const char autostartsh[] = "autostart.sh";
++static const char broken[] = "broken";
++static const char dwmdir[] = "dwm";
++static const char localshare[] = ".local/share";
++static char stext[1024];
++static int screen;
++static int sw, sh;           /* X display screen geometry width, height */
++static int bh, blw = 0;      /* bar geometry */
++static int lrpad;            /* sum of left and right padding for text */
++static int (*xerrorxlib)(Display *, XErrorEvent *);
++static unsigned int numlockmask = 0;
++static void (*handler[LASTEvent]) (XEvent *) = {
++	[ButtonPress] = buttonpress,
++	[ClientMessage] = clientmessage,
++	[ConfigureRequest] = configurerequest,
++	[ConfigureNotify] = configurenotify,
++	[DestroyNotify] = destroynotify,
++	[EnterNotify] = enternotify,
++	[Expose] = expose,
++	[FocusIn] = focusin,
++	[KeyPress] = keypress,
++	[MappingNotify] = mappingnotify,
++	[MapRequest] = maprequest,
++	[MotionNotify] = motionnotify,
++	[PropertyNotify] = propertynotify,
++	[UnmapNotify] = unmapnotify
++};
++static Atom wmatom[WMLast], netatom[NetLast];
++static int restart = 0;
++static int running = 1;
++static Cur *cursor[CurLast];
++static Clr **scheme;
++static Display *dpy;
++static Drw *drw;
++static Monitor *mons, *selmon;
++static Window root, wmcheckwin;
++
++static xcb_connection_t *xcon;
++
++/* configuration, allows nested code to access above variables */
++#include "config.h"
++
++/* compile-time check if all tags fit into an unsigned int bit array. */
++struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
++
++/* function implementations */
++void
++applyrules(Client *c)
++{
++	const char *class, *instance;
++	unsigned int i;
++	const Rule *r;
++	Monitor *m;
++	XClassHint ch = { NULL, NULL };
++
++	/* rule matching */
++	c->isfloating = 0;
++	c->tags = 0;
++	XGetClassHint(dpy, c->win, &ch);
++	class    = ch.res_class ? ch.res_class : broken;
++	instance = ch.res_name  ? ch.res_name  : broken;
++
++	for (i = 0; i < LENGTH(rules); i++) {
++		r = &rules[i];
++		if ((!r->title || strstr(c->name, r->title))
++		&& (!r->class || strstr(class, r->class))
++		&& (!r->instance || strstr(instance, r->instance)))
++		{
++			c->isterminal = r->isterminal;
++			c->noswallow  = r->noswallow;
++			c->isfloating = r->isfloating;
++			c->tags |= r->tags;
++			for (m = mons; m && m->num != r->monitor; m = m->next);
++			if (m)
++				c->mon = m;
++		}
++	}
++	if (ch.res_class)
++		XFree(ch.res_class);
++	if (ch.res_name)
++		XFree(ch.res_name);
++	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
++}
++
++int
++applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
++{
++	int baseismin;
++	Monitor *m = c->mon;
++
++	/* set minimum possible */
++	*w = MAX(1, *w);
++	*h = MAX(1, *h);
++	if (interact) {
++		if (*x > sw)
++			*x = sw - WIDTH(c);
++		if (*y > sh)
++			*y = sh - HEIGHT(c);
++		if (*x + *w + 2 * c->bw < 0)
++			*x = 0;
++		if (*y + *h + 2 * c->bw < 0)
++			*y = 0;
++	} else {
++		if (*x >= m->wx + m->ww)
++			*x = m->wx + m->ww - WIDTH(c);
++		if (*y >= m->wy + m->wh)
++			*y = m->wy + m->wh - HEIGHT(c);
++		if (*x + *w + 2 * c->bw <= m->wx)
++			*x = m->wx;
++		if (*y + *h + 2 * c->bw <= m->wy)
++			*y = m->wy;
++	}
++	if (*h < bh)
++		*h = bh;
++	if (*w < bh)
++		*w = bh;
++	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
++		/* see last two sentences in ICCCM 4.1.2.3 */
++		baseismin = c->basew == c->minw && c->baseh == c->minh;
++		if (!baseismin) { /* temporarily remove base dimensions */
++			*w -= c->basew;
++			*h -= c->baseh;
++		}
++		/* adjust for aspect limits */
++		if (c->mina > 0 && c->maxa > 0) {
++			if (c->maxa < (float)*w / *h)
++				*w = *h * c->maxa + 0.5;
++			else if (c->mina < (float)*h / *w)
++				*h = *w * c->mina + 0.5;
++		}
++		if (baseismin) { /* increment calculation requires this */
++			*w -= c->basew;
++			*h -= c->baseh;
++		}
++		/* adjust for increment value */
++		if (c->incw)
++			*w -= *w % c->incw;
++		if (c->inch)
++			*h -= *h % c->inch;
++		/* restore base dimensions */
++		*w = MAX(*w + c->basew, c->minw);
++		*h = MAX(*h + c->baseh, c->minh);
++		if (c->maxw)
++			*w = MIN(*w, c->maxw);
++		if (c->maxh)
++			*h = MIN(*h, c->maxh);
++	}
++	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
++}
++
++void
++arrange(Monitor *m)
++{
++	if (m)
++		showhide(m->stack);
++	else for (m = mons; m; m = m->next)
++		showhide(m->stack);
++	if (m) {
++		arrangemon(m);
++		restack(m);
++	} else for (m = mons; m; m = m->next)
++		arrangemon(m);
++}
++
++void
++arrangemon(Monitor *m)
++{
++	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
++	if (m->lt[m->sellt]->arrange)
++		m->lt[m->sellt]->arrange(m);
++}
++
++void
++attach(Client *c)
++{
++	c->next = c->mon->clients;
++	c->mon->clients = c;
++}
++
++void
++attachabove(Client *c)
++{
++	if (c->mon->sel == NULL || c->mon->sel == c->mon->clients || c->mon->sel->isfloating) {
++		attach(c);
++		return;
++	}
++
++	Client *at;
++	for (at = c->mon->clients; at->next != c->mon->sel; at = at->next);
++	c->next = at->next;
++	at->next = c;
++}
++
++void
++attachaside(Client *c) {
++	Client *at = nexttagged(c);
++	if(!at) {
++		attach(c);
++		return;
++		}
++	c->next = at->next;
++	at->next = c;
++}
++
++void
++attachbelow(Client *c)
++{
++	if(c->mon->sel == NULL || c->mon->sel == c || c->mon->sel->isfloating) {
++		attach(c);
++		return;
++	}
++	c->next = c->mon->sel->next;
++	c->mon->sel->next = c;
++}
++ 
++void
++attachbottom(Client *c)
++{
++	Client *below = c->mon->clients;
++	for (; below && below->next; below = below->next);
++	c->next = NULL;
++	if (below)
++		below->next = c;
++	else
++		c->mon->clients = c;
++}
++
++void
++attachtop(Client *c)
++{
++	int n;
++	Monitor *m = selmon;
++	Client *below;
++
++	for (n = 1, below = c->mon->clients;
++		below && below->next && (below->isfloating || !ISVISIBLEONTAG(below, c->tags) || n != m->nmaster);
++		n = below->isfloating || !ISVISIBLEONTAG(below, c->tags) ? n + 0 : n + 1, below = below->next);
++	c->next = NULL;
++	if (below) {
++		c->next = below->next;
++		below->next = c;
++	}
++	else
++		c->mon->clients = c;
++}
++
++void
++attachstack(Client *c)
++{
++	c->snext = c->mon->stack;
++	c->mon->stack = c;
++}
++
++void
++swallow(Client *p, Client *c)
++{
++
++	if (c->noswallow || c->isterminal)
++		return;
++	if (c->noswallow && !swallowfloating && c->isfloating)
++		return;
++
++	detach(c);
++	detachstack(c);
++
++	setclientstate(c, WithdrawnState);
++	XUnmapWindow(dpy, p->win);
++
++	p->swallowing = c;
++	c->mon = p->mon;
++
++	Window w = p->win;
++	p->win = c->win;
++	c->win = w;
++	updatetitle(p);
++	XMoveResizeWindow(dpy, p->win, p->x, p->y, p->w, p->h);
++	arrange(p->mon);
++	configure(p);
++	updateclientlist();
++}
++
++void
++unswallow(Client *c)
++{
++	c->win = c->swallowing->win;
++
++	free(c->swallowing);
++	c->swallowing = NULL;
++
++	/* unfullscreen the client */
++	setfullscreen(c, 0);
++	updatetitle(c);
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	setclientstate(c, NormalState);
++	focus(NULL);
++	arrange(c->mon);
++}
++
++void
++buttonpress(XEvent *e)
++{
++	unsigned int i, x, click;
++	Arg arg = {0};
++	Client *c;
++	Monitor *m;
++	XButtonPressedEvent *ev = &e->xbutton;
++
++	click = ClkRootWin;
++	/* focus monitor if necessary */
++	if ((m = wintomon(ev->window)) && m != selmon) {
++		unfocus(selmon->sel, 1);
++		selmon = m;
++		focus(NULL);
++	}
++	if (ev->window == selmon->barwin) {
++		i = x = 0;
++		do
++			x += TEXTW(tags[i]);
++		while (ev->x >= x && ++i < LENGTH(tags));
++		if (i < LENGTH(tags)) {
++			click = ClkTagBar;
++			arg.ui = 1 << i;
++		} else if (ev->x < x + blw)
++			click = ClkLtSymbol;
++		else if (ev->x > selmon->ww - (int)TEXTW(stext))
++			click = ClkStatusText;
++		else
++			click = ClkWinTitle;
++	} else if ((c = wintoclient(ev->window))) {
++		focus(c);
++		restack(selmon);
++		XAllowEvents(dpy, ReplayPointer, CurrentTime);
++		click = ClkClientWin;
++	}
++	for (i = 0; i < LENGTH(buttons); i++)
++		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
++		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
++			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
++}
++
++void
++checkotherwm(void)
++{
++	xerrorxlib = XSetErrorHandler(xerrorstart);
++	/* this causes an error if some other window manager is running */
++	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
++	XSync(dpy, False);
++	XSetErrorHandler(xerror);
++	XSync(dpy, False);
++}
++
++void
++cleanup(void)
++{
++	Arg a = {.ui = ~0};
++	Layout foo = { "", NULL };
++	Monitor *m;
++	size_t i;
++
++	view(&a);
++	selmon->lt[selmon->sellt] = &foo;
++	for (m = mons; m; m = m->next)
++		while (m->stack)
++			unmanage(m->stack, 0);
++	XUngrabKey(dpy, AnyKey, AnyModifier, root);
++	while (mons)
++		cleanupmon(mons);
++	for (i = 0; i < CurLast; i++)
++		drw_cur_free(drw, cursor[i]);
++	for (i = 0; i < LENGTH(colors) + 1; i++)
++		free(scheme[i]);
++	XDestroyWindow(dpy, wmcheckwin);
++	drw_free(drw);
++	XSync(dpy, False);
++	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
++	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++}
++
++void
++cleanupmon(Monitor *mon)
++{
++	Monitor *m;
++
++	if (mon == mons)
++		mons = mons->next;
++	else {
++		for (m = mons; m && m->next != mon; m = m->next);
++		m->next = mon->next;
++	}
++	XUnmapWindow(dpy, mon->barwin);
++	XDestroyWindow(dpy, mon->barwin);
++	free(mon);
++}
++
++void
++clientmessage(XEvent *e)
++{
++	XClientMessageEvent *cme = &e->xclient;
++	Client *c = wintoclient(cme->window);
++	unsigned int i;
++
++	if (!c)
++		return;
++	if (cme->message_type == netatom[NetWMState]) {
++		if (cme->data.l[1] == netatom[NetWMFullscreen]
++		|| cme->data.l[2] == netatom[NetWMFullscreen])
++			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
++				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++	} else if (cme->message_type == netatom[NetActiveWindow]) {
++		for (i = 0; i < LENGTH(tags) && !((1 << i) & c->tags); i++);
++		if (i < LENGTH(tags)) {
++			const Arg a = {.ui = 1 << i};
++			selmon = c->mon;
++			view(&a);
++			focus(c);
++			restack(selmon);
++		}
++	}
++}
++
++void
++configure(Client *c)
++{
++	XConfigureEvent ce;
++
++	ce.type = ConfigureNotify;
++	ce.display = dpy;
++	ce.event = c->win;
++	ce.window = c->win;
++	ce.x = c->x;
++	ce.y = c->y;
++	ce.width = c->w;
++	ce.height = c->h;
++	ce.border_width = c->bw;
++	ce.above = None;
++	ce.override_redirect = False;
++	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
++}
++
++void
++configurenotify(XEvent *e)
++{
++	Monitor *m;
++	Client *c;
++	XConfigureEvent *ev = &e->xconfigure;
++	int dirty;
++
++	/* TODO: updategeom handling sucks, needs to be simplified */
++	if (ev->window == root) {
++		dirty = (sw != ev->width || sh != ev->height);
++		sw = ev->width;
++		sh = ev->height;
++		if (updategeom() || dirty) {
++			drw_resize(drw, sw, bh);
++			updatebars();
++			for (m = mons; m; m = m->next) {
++				for (c = m->clients; c; c = c->next)
++					if (c->isfullscreen)
++						resizeclient(c, m->mx, m->my, m->mw, m->mh);
++				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
++			}
++			focus(NULL);
++			arrange(NULL);
++		}
++	}
++}
++
++void
++configurerequest(XEvent *e)
++{
++	Client *c;
++	Monitor *m;
++	XConfigureRequestEvent *ev = &e->xconfigurerequest;
++	XWindowChanges wc;
++
++	if ((c = wintoclient(ev->window))) {
++		if (ev->value_mask & CWBorderWidth)
++			c->bw = ev->border_width;
++		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
++			m = c->mon;
++			if (ev->value_mask & CWX) {
++				c->oldx = c->x;
++				c->x = m->mx + ev->x;
++			}
++			if (ev->value_mask & CWY) {
++				c->oldy = c->y;
++				c->y = m->my + ev->y;
++			}
++			if (ev->value_mask & CWWidth) {
++				c->oldw = c->w;
++				c->w = ev->width;
++			}
++			if (ev->value_mask & CWHeight) {
++				c->oldh = c->h;
++				c->h = ev->height;
++			}
++			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
++				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
++			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
++				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
++			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
++				configure(c);
++			if (ISVISIBLE(c))
++				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++		} else
++			configure(c);
++	} else {
++		wc.x = ev->x;
++		wc.y = ev->y;
++		wc.width = ev->width;
++		wc.height = ev->height;
++		wc.border_width = ev->border_width;
++		wc.sibling = ev->above;
++		wc.stack_mode = ev->detail;
++		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
++	}
++	XSync(dpy, False);
++}
++
++Monitor *
++createmon(void)
++{
++	Monitor *m;
++
++	m = ecalloc(1, sizeof(Monitor));
++	m->tagset[0] = m->tagset[1] = 1;
++	m->mfact = mfact;
++	m->nmaster = nmaster;
++	m->showbar = showbar;
++	m->topbar = topbar;
++	m->gappih = gappih;
++	m->gappiv = gappiv;
++	m->gappoh = gappoh;
++	m->gappov = gappov;
++	m->lt[0] = &layouts[0];
++	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++	return m;
++}
++
++void
++destroynotify(XEvent *e)
++{
++	Client *c;
++	XDestroyWindowEvent *ev = &e->xdestroywindow;
++
++	if ((c = wintoclient(ev->window)))
++		unmanage(c, 1);
++
++	else if ((c = swallowingclient(ev->window)))
++		unmanage(c->swallowing, 1);
++}
++
++void
++detach(Client *c)
++{
++	Client **tc;
++
++	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
++	*tc = c->next;
++}
++
++void
++detachstack(Client *c)
++{
++	Client **tc, *t;
++
++	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
++	*tc = c->snext;
++
++	if (c == c->mon->sel) {
++		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
++		c->mon->sel = t;
++	}
++}
++
++Monitor *
++dirtomon(int dir)
++{
++	Monitor *m = NULL;
++
++	if (dir > 0) {
++		if (!(m = selmon->next))
++			m = mons;
++	} else if (selmon == mons)
++		for (m = mons; m->next; m = m->next);
++	else
++		for (m = mons; m->next != selmon; m = m->next);
++	return m;
++}
++
++int
++drawstatusbar(Monitor *m, int bh, char* stext) {
++	int ret, i, w, x, len;
++	short isCode = 0;
++	char *text;
++	char *p;
++
++	len = strlen(stext) + 1 ;
++	if (!(text = (char*) malloc(sizeof(char)*len)))
++		die("malloc");
++	p = text;
++	memcpy(text, stext, len);
++
++	/* compute width of the status text */
++	w = 0;
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^') {
++			if (!isCode) {
++				isCode = 1;
++				text[i] = '\0';
++				w += TEXTW(text) - lrpad;
++				text[i] = '^';
++				if (text[++i] == 'f')
++					w += atoi(text + ++i);
++			} else {
++				isCode = 0;
++				text = text + i + 1;
++				i = -1;
++			}
++		}
++	}
++	if (!isCode)
++		w += TEXTW(text) - lrpad;
++	else
++		isCode = 0;
++	text = p;
++
++	w += 2; /* 1px padding on both sides */
++	ret = x = m->ww - w;
++
++	drw_setscheme(drw, scheme[LENGTH(colors)]);
++	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++	drw_rect(drw, x, 0, w, bh, 1, 1);
++	x++;
++
++	/* process status text */
++	i = -1;
++	while (text[++i]) {
++		if (text[i] == '^' && !isCode) {
++			isCode = 1;
++
++			text[i] = '\0';
++			w = TEXTW(text) - lrpad;
++			drw_text(drw, x, 0, w, bh, 0, text, 0);
++
++			x += w;
++
++			/* process code */
++			while (text[++i] != '^') {
++				if (text[i] == 'c') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColFg], buf);
++					i += 7;
++				} else if (text[i] == 'b') {
++					char buf[8];
++					memcpy(buf, (char*)text+i+1, 7);
++					buf[7] = '\0';
++					drw_clr_create(drw, &drw->scheme[ColBg], buf);
++					i += 7;
++				} else if (text[i] == 'd') {
++					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
++					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
++				} else if (text[i] == 'r') {
++					int rx = atoi(text + ++i);
++					while (text[++i] != ',');
++					int ry = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rw = atoi(text + ++i);
++					while (text[++i] != ',');
++					int rh = atoi(text + ++i);
++
++					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
++				} else if (text[i] == 'f') {
++					x += atoi(text + ++i);
++				}
++			}
++
++			text = text + i + 1;
++			i=-1;
++			isCode = 0;
++		}
++	}
++
++	if (!isCode) {
++		w = TEXTW(text) - lrpad;
++		drw_text(drw, x, 0, w, bh, 0, text, 0);
++	}
++
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	free(p);
++
++	return ret;
++}
++
++void
++drawbar(Monitor *m)
++{
++	int x, w, tw = 0;
++	int boxs = drw->fonts->h / 9;
++	int boxw = drw->fonts->h / 6 + 2;
++	unsigned int i, occ = 0, urg = 0;
++	Client *c;
++
++	/* draw status first so it can be overdrawn by tags later */
++	if (m == selmon) { /* status is only drawn on selected monitor */
++		tw = m->ww - drawstatusbar(m, bh, stext);
++	}
++
++	for (c = m->clients; c; c = c->next) {
++		occ |= c->tags;
++		if (c->isurgent)
++			urg |= c->tags;
++	}
++	x = 0;
++	for (i = 0; i < LENGTH(tags); i++) {
++		w = TEXTW(tags[i]);
++		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
++		if (occ & 1 << i)
++			drw_rect(drw, x + boxs, boxs, boxw, boxw,
++				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
++				urg & 1 << i);
++		x += w;
++	}
++	w = blw = TEXTW(m->ltsymbol);
++	drw_setscheme(drw, scheme[SchemeNorm]);
++	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
++
++	if ((w = m->ww - tw - x) > bh) {
++		if (m->sel) {
++			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
++			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
++			if (m->sel->isfloating)
++				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
++		} else {
++			drw_setscheme(drw, scheme[SchemeNorm]);
++			drw_rect(drw, x, 0, w, bh, 1, 1);
++		}
++	}
++	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
++}
++
++void
++drawbars(void)
++{
++	Monitor *m;
++
++	for (m = mons; m; m = m->next)
++		drawbar(m);
++}
++
++void
++enternotify(XEvent *e)
++{
++	Client *c;
++	Monitor *m;
++	XCrossingEvent *ev = &e->xcrossing;
++
++	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
++		return;
++	c = wintoclient(ev->window);
++	m = c ? c->mon : wintomon(ev->window);
++	if (m != selmon) {
++		unfocus(selmon->sel, 1);
++		selmon = m;
++	} else if (!c || c == selmon->sel)
++		return;
++	focus(c);
++}
++
++void
++expose(XEvent *e)
++{
++	Monitor *m;
++	XExposeEvent *ev = &e->xexpose;
++
++	if (ev->count == 0 && (m = wintomon(ev->window)))
++		drawbar(m);
++}
++
++void
++focus(Client *c)
++{
++	if (!c || !ISVISIBLE(c))
++		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
++	if (selmon->sel && selmon->sel != c)
++		unfocus(selmon->sel, 0);
++	if (c) {
++		if (c->mon != selmon)
++			selmon = c->mon;
++		if (c->isurgent)
++			seturgent(c, 0);
++		detachstack(c);
++		attachstack(c);
++		grabbuttons(c, 1);
++		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
++		setfocus(c);
++	} else {
++		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++	}
++	selmon->sel = c;
++	drawbars();
++}
++
++/* there are some broken focus acquiring clients needing extra handling */
++void
++focusin(XEvent *e)
++{
++	XFocusChangeEvent *ev = &e->xfocus;
++
++	if (selmon->sel && ev->window != selmon->sel->win)
++		setfocus(selmon->sel);
++}
++
++void
++focusmon(const Arg *arg)
++{
++	Monitor *m;
++
++	if (!mons->next)
++		return;
++	if ((m = dirtomon(arg->i)) == selmon)
++		return;
++	unfocus(selmon->sel, 0);
++	selmon = m;
++	focus(NULL);
++}
++
++void
++focusstack(const Arg *arg)
++{
++	Client *c = NULL, *i;
++
++	if (!selmon->sel)
++		return;
++	if (arg->i > 0) {
++		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
++		if (!c)
++			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
++	} else {
++		for (i = selmon->clients; i != selmon->sel; i = i->next)
++			if (ISVISIBLE(i))
++				c = i;
++		if (!c)
++			for (; i; i = i->next)
++				if (ISVISIBLE(i))
++					c = i;
++	}
++	if (c) {
++		focus(c);
++		restack(selmon);
++	}
++}
++
++Atom
++getatomprop(Client *c, Atom prop)
++{
++	int di;
++	unsigned long dl;
++	unsigned char *p = NULL;
++	Atom da, atom = None;
++
++	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
++		&da, &di, &dl, &dl, &p) == Success && p) {
++		atom = *(Atom *)p;
++		XFree(p);
++	}
++	return atom;
++}
++
++int
++getrootptr(int *x, int *y)
++{
++	int di;
++	unsigned int dui;
++	Window dummy;
++
++	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
++}
++
++long
++getstate(Window w)
++{
++	int format;
++	long result = -1;
++	unsigned char *p = NULL;
++	unsigned long n, extra;
++	Atom real;
++
++	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
++		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
++		return -1;
++	if (n != 0)
++		result = *p;
++	XFree(p);
++	return result;
++}
++
++int
++gettextprop(Window w, Atom atom, char *text, unsigned int size)
++{
++	char **list = NULL;
++	int n;
++	XTextProperty name;
++
++	if (!text || size == 0)
++		return 0;
++	text[0] = '\0';
++	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
++		return 0;
++	if (name.encoding == XA_STRING)
++		strncpy(text, (char *)name.value, size - 1);
++	else {
++		if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
++			strncpy(text, *list, size - 1);
++			XFreeStringList(list);
++		}
++	}
++	text[size - 1] = '\0';
++	XFree(name.value);
++	return 1;
++}
++
++void
++grabbuttons(Client *c, int focused)
++{
++	updatenumlockmask();
++	{
++		unsigned int i, j;
++		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++		if (!focused)
++			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
++				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
++		for (i = 0; i < LENGTH(buttons); i++)
++			if (buttons[i].click == ClkClientWin)
++				for (j = 0; j < LENGTH(modifiers); j++)
++					XGrabButton(dpy, buttons[i].button,
++						buttons[i].mask | modifiers[j],
++						c->win, False, BUTTONMASK,
++						GrabModeAsync, GrabModeSync, None, None);
++	}
++}
++
++void
++grabkeys(void)
++{
++	updatenumlockmask();
++	{
++		unsigned int i, j;
++		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
++		KeyCode code;
++
++		XUngrabKey(dpy, AnyKey, AnyModifier, root);
++		for (i = 0; i < LENGTH(keys); i++)
++			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
++				for (j = 0; j < LENGTH(modifiers); j++)
++					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
++						True, GrabModeAsync, GrabModeAsync);
++	}
++}
++
++void
++incnmaster(const Arg *arg)
++{
++	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++	arrange(selmon);
++}
++
++#ifdef XINERAMA
++static int
++isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
++{
++	while (n--)
++		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
++		&& unique[n].width == info->width && unique[n].height == info->height)
++			return 0;
++	return 1;
++}
++#endif /* XINERAMA */
++
++void
++keypress(XEvent *e)
++{
++	unsigned int i;
++	KeySym keysym;
++	XKeyEvent *ev;
++
++	ev = &e->xkey;
++	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
++	for (i = 0; i < LENGTH(keys); i++)
++		if (keysym == keys[i].keysym
++		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
++		&& keys[i].func)
++			keys[i].func(&(keys[i].arg));
++}
++
++void
++killclient(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
++		XGrabServer(dpy);
++		XSetErrorHandler(xerrordummy);
++		XSetCloseDownMode(dpy, DestroyAll);
++		XKillClient(dpy, selmon->sel->win);
++		XSync(dpy, False);
++		XSetErrorHandler(xerror);
++		XUngrabServer(dpy);
++	}
++}
++
++void
++manage(Window w, XWindowAttributes *wa)
++{
++	Client *c, *t = NULL, *term = NULL;
++	Window trans = None;
++	XWindowChanges wc;
++
++	c = ecalloc(1, sizeof(Client));
++	c->win = w;
++	c->pid = winpid(w);
++	/* geometry */
++	c->x = c->oldx = wa->x;
++	c->y = c->oldy = wa->y;
++	c->w = c->oldw = wa->width;
++	c->h = c->oldh = wa->height;
++	c->oldbw = wa->border_width;
++
++	updatetitle(c);
++	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
++		c->mon = t->mon;
++		c->tags = t->tags;
++	} else {
++		c->mon = selmon;
++		applyrules(c);
++		term = termforwin(c);
++	}
++
++	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
++		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
++	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
++		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
++	c->x = MAX(c->x, c->mon->mx);
++	/* only fix client y-offset, if the client center might cover the bar */
++	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
++		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
++	c->bw = borderpx;
++
++	wc.border_width = c->bw;
++	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
++	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
++	configure(c); /* propagates border_width, if size doesn't change */
++	updatewindowtype(c);
++	updatesizehints(c);
++	updatewmhints(c);
++	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
++	grabbuttons(c, 0);
++	if (!c->isfloating)
++		c->isfloating = c->oldstate = trans != None || c->isfixed;
++	if (c->isfloating)
++		XRaiseWindow(dpy, c->win);
++	switch(attachdirection){
++		case 1:
++			attachabove(c);
++			break;
++		case 2:
++			attachaside(c);
++			break;
++		case 3:
++			attachbelow(c);
++			break;
++		case 4:
++			attachbottom(c);
++			break;
++		case 5:
++			attachtop(c);
++			break;
++		default:
++			attach(c);
++	}
++	attachstack(c);
++	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
++		(unsigned char *) &(c->win), 1);
++	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
++	setclientstate(c, NormalState);
++	if (c->mon == selmon)
++		unfocus(selmon->sel, 0);
++	c->mon->sel = c;
++	arrange(c->mon);
++	XMapWindow(dpy, c->win);
++	if (term)
++		swallow(term, c);
++	focus(NULL);
++}
++
++void
++mappingnotify(XEvent *e)
++{
++	XMappingEvent *ev = &e->xmapping;
++
++	XRefreshKeyboardMapping(ev);
++	if (ev->request == MappingKeyboard)
++		grabkeys();
++}
++
++void
++maprequest(XEvent *e)
++{
++	static XWindowAttributes wa;
++	XMapRequestEvent *ev = &e->xmaprequest;
++
++	if (!XGetWindowAttributes(dpy, ev->window, &wa))
++		return;
++	if (wa.override_redirect)
++		return;
++	if (!wintoclient(ev->window))
++		manage(ev->window, &wa);
++}
++
++void
++monocle(Monitor *m)
++{
++	unsigned int n = 0;
++	Client *c;
++
++	for (c = m->clients; c; c = c->next)
++		if (ISVISIBLE(c))
++			n++;
++	if (n > 0) /* override layout symbol */
++		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
++	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
++		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
++}
++
++void
++motionnotify(XEvent *e)
++{
++	static Monitor *mon = NULL;
++	Monitor *m;
++	XMotionEvent *ev = &e->xmotion;
++
++	if (ev->window != root)
++		return;
++	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
++		unfocus(selmon->sel, 1);
++		selmon = m;
++		focus(NULL);
++	}
++	mon = m;
++}
++
++void
++movemouse(const Arg *arg)
++{
++	int x, y, ocx, ocy, nx, ny;
++	Client *c;
++	Monitor *m;
++	XEvent ev;
++	Time lasttime = 0;
++
++	if (!(c = selmon->sel))
++		return;
++	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
++		return;
++	restack(selmon);
++	ocx = c->x;
++	ocy = c->y;
++	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
++		return;
++	if (!getrootptr(&x, &y))
++		return;
++	do {
++		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++		switch(ev.type) {
++		case ConfigureRequest:
++		case Expose:
++		case MapRequest:
++			handler[ev.type](&ev);
++			break;
++		case MotionNotify:
++			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++				continue;
++			lasttime = ev.xmotion.time;
++
++			nx = ocx + (ev.xmotion.x - x);
++			ny = ocy + (ev.xmotion.y - y);
++			if (abs(selmon->wx - nx) < snap)
++				nx = selmon->wx;
++			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
++				nx = selmon->wx + selmon->ww - WIDTH(c);
++			if (abs(selmon->wy - ny) < snap)
++				ny = selmon->wy;
++			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
++				ny = selmon->wy + selmon->wh - HEIGHT(c);
++			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
++				togglefloating(NULL);
++			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++				resize(c, nx, ny, c->w, c->h, 1);
++			break;
++		}
++	} while (ev.type != ButtonRelease);
++	XUngrabPointer(dpy, CurrentTime);
++	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++		sendmon(c, m);
++		selmon = m;
++		focus(NULL);
++	}
++}
++
++Client *
++nexttagged(Client *c) {
++	Client *walked = c->mon->clients;
++	for(;
++		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
++		walked = walked->next
++	);
++	return walked;
++}
++
++Client *
++nexttiled(Client *c)
++{
++	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
++	return c;
++}
++
++void
++pop(Client *c)
++{
++	detach(c);
++	attach(c);
++	focus(c);
++	arrange(c->mon);
++}
++
++Client *
++prevtiled(Client *c) {
++	Client *p, *r;
++
++	for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
++		if(!p->isfloating && ISVISIBLE(p))
++			r = p;
++	return r;
++}
++
++void
++propertynotify(XEvent *e)
++{
++	Client *c;
++	Window trans;
++	XPropertyEvent *ev = &e->xproperty;
++
++	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
++		updatestatus();
++	else if (ev->state == PropertyDelete)
++		return; /* ignore */
++	else if ((c = wintoclient(ev->window))) {
++		switch(ev->atom) {
++		default: break;
++		case XA_WM_TRANSIENT_FOR:
++			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
++				(c->isfloating = (wintoclient(trans)) != NULL))
++				arrange(c->mon);
++			break;
++		case XA_WM_NORMAL_HINTS:
++			updatesizehints(c);
++			break;
++		case XA_WM_HINTS:
++			updatewmhints(c);
++			drawbars();
++			break;
++		}
++		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
++			updatetitle(c);
++			if (c == c->mon->sel)
++				drawbar(c->mon);
++		}
++		if (ev->atom == netatom[NetWMWindowType])
++			updatewindowtype(c);
++	}
++}
++
++void
++pushdown(const Arg *arg) {
++	Client *sel = selmon->sel, *c;
++
++	if(!sel || sel->isfloating || sel == nexttiled(selmon->clients))
++		return;
++	if((c = nexttiled(sel->next))) {
++		detach(sel);
++		sel->next = c->next;
++		c->next = sel;
++	}
++	focus(sel);
++	arrange(selmon);
++}
++
++void
++pushup(const Arg *arg) {
++	Client *sel = selmon->sel, *c;
++
++	if(!sel || sel->isfloating)
++		return;
++	if((c = prevtiled(sel)) && c != nexttiled(selmon->clients)) {
++		detach(sel);
++		sel->next = c;
++		for(c = selmon->clients; c->next != sel->next; c = c->next);
++		c->next = sel;
++	}
++	focus(sel);
++	arrange(selmon);
++}
++
++void
++quit(const Arg *arg)
++{
++	if(arg->i) restart = 1;
++	running = 0;
++}
++
++Monitor *
++recttomon(int x, int y, int w, int h)
++{
++	Monitor *m, *r = selmon;
++	int a, area = 0;
++
++	for (m = mons; m; m = m->next)
++		if ((a = INTERSECT(x, y, w, h, m)) > area) {
++			area = a;
++			r = m;
++		}
++	return r;
++}
++
++void
++resize(Client *c, int x, int y, int w, int h, int interact)
++{
++	if (applysizehints(c, &x, &y, &w, &h, interact))
++		resizeclient(c, x, y, w, h);
++}
++
++void
++resizeclient(Client *c, int x, int y, int w, int h)
++{
++	XWindowChanges wc;
++
++	c->oldx = c->x; c->x = wc.x = x;
++	c->oldy = c->y; c->y = wc.y = y;
++	c->oldw = c->w; c->w = wc.width = w;
++	c->oldh = c->h; c->h = wc.height = h;
++	wc.border_width = c->bw;
++	if (((nexttiled(c->mon->clients) == c && !nexttiled(c->next))
++	    || &monocle == c->mon->lt[c->mon->sellt]->arrange)
++	    && !c->isfullscreen && !c->isfloating
++	    && NULL != c->mon->lt[c->mon->sellt]->arrange) {
++		c->w = wc.width += c->bw * 2;
++		c->h = wc.height += c->bw * 2;
++		wc.border_width = 0;
++	}
++	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
++	configure(c);
++	XSync(dpy, False);
++}
++
++void
++resizemouse(const Arg *arg)
++{
++	int ocx, ocy, nw, nh;
++	Client *c;
++	Monitor *m;
++	XEvent ev;
++	Time lasttime = 0;
++
++	if (!(c = selmon->sel))
++		return;
++	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
++		return;
++	restack(selmon);
++	ocx = c->x;
++	ocy = c->y;
++	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
++		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
++		return;
++	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++	do {
++		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
++		switch(ev.type) {
++		case ConfigureRequest:
++		case Expose:
++		case MapRequest:
++			handler[ev.type](&ev);
++			break;
++		case MotionNotify:
++			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
++				continue;
++			lasttime = ev.xmotion.time;
++
++			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
++			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
++			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
++			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
++			{
++				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
++				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
++					togglefloating(NULL);
++			}
++			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
++				resize(c, c->x, c->y, nw, nh, 1);
++			break;
++		}
++	} while (ev.type != ButtonRelease);
++	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
++	XUngrabPointer(dpy, CurrentTime);
++	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
++		sendmon(c, m);
++		selmon = m;
++		focus(NULL);
++	}
++}
++
++void
++restack(Monitor *m)
++{
++	Client *c;
++	XEvent ev;
++	XWindowChanges wc;
++
++	drawbar(m);
++	if (!m->sel)
++		return;
++	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
++		XRaiseWindow(dpy, m->sel->win);
++	if (m->lt[m->sellt]->arrange) {
++		wc.stack_mode = Below;
++		wc.sibling = m->barwin;
++		for (c = m->stack; c; c = c->snext)
++			if (!c->isfloating && ISVISIBLE(c)) {
++				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
++				wc.sibling = c->win;
++			}
++	}
++	XSync(dpy, False);
++	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
++}
++
++void
++run(void)
++{
++	XEvent ev;
++	/* main event loop */
++	XSync(dpy, False);
++	while (running && !XNextEvent(dpy, &ev))
++		if (handler[ev.type])
++			handler[ev.type](&ev); /* call handler */
++}
++
++void
++runautostart(void)
++{
++	char *pathpfx;
++	char *path;
++	char *xdgdatahome;
++	char *home;
++	struct stat sb;
++
++	if ((home = getenv("HOME")) == NULL)
++		/* this is almost impossible */
++		return;
++
++	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
++	 * otherwise use ~/.local/share/dwm as autostart script directory
++	 */
++	xdgdatahome = getenv("XDG_DATA_HOME");
++	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
++
++		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	} else {
++		/* space for path segments, separators and nul */
++		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
++		                     + strlen(dwmdir) + 3);
++
++		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* check if the autostart script directory exists */
++	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
++		/* the XDG conformant path does not exist or is no directory
++		 * so we try ~/.dwm instead
++		 */
++		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
++		if(pathpfx_new == NULL) {
++			free(pathpfx);
++			return;
++		}
++   pathpfx = pathpfx_new;
++
++		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
++			free(pathpfx);
++			return;
++		}
++	}
++
++	/* try the blocking script first */
++	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
++	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(path);
++
++	/* now the non-blocking script */
++	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
++		free(path);
++		free(pathpfx);
++	}
++
++	if (access(path, X_OK) == 0)
++		system(strcat(path, " &"));
++
++	free(pathpfx);
++	free(path);
++}
++
++void
++scan(void)
++{
++	unsigned int i, num;
++	Window d1, d2, *wins = NULL;
++	XWindowAttributes wa;
++
++	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
++		for (i = 0; i < num; i++) {
++			if (!XGetWindowAttributes(dpy, wins[i], &wa)
++			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
++				continue;
++			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
++				manage(wins[i], &wa);
++		}
++		for (i = 0; i < num; i++) { /* now the transients */
++			if (!XGetWindowAttributes(dpy, wins[i], &wa))
++				continue;
++			if (XGetTransientForHint(dpy, wins[i], &d1)
++			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
++				manage(wins[i], &wa);
++		}
++		if (wins)
++			XFree(wins);
++	}
++}
++
++void
++sendmon(Client *c, Monitor *m)
++{
++	if (c->mon == m)
++		return;
++	unfocus(c, 1);
++	detach(c);
++	detachstack(c);
++	c->mon = m;
++	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
++	switch(attachdirection){
++		case 1:
++			attachabove(c);
++			break;
++		case 2:
++			attachaside(c);
++			break;
++		case 3:
++			attachbelow(c);
++			break;
++		case 4:
++			attachbottom(c);
++			break;
++		case 5:
++			attachtop(c);
++			break;
++		default:
++			attach(c);
++	}
++	attachstack(c);
++	focus(NULL);
++	arrange(NULL);
++}
++
++void
++setclientstate(Client *c, long state)
++{
++	long data[] = { state, None };
++
++	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
++		PropModeReplace, (unsigned char *)data, 2);
++}
++
++int
++sendevent(Client *c, Atom proto)
++{
++	int n;
++	Atom *protocols;
++	int exists = 0;
++	XEvent ev;
++
++	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
++		while (!exists && n--)
++			exists = protocols[n] == proto;
++		XFree(protocols);
++	}
++	if (exists) {
++		ev.type = ClientMessage;
++		ev.xclient.window = c->win;
++		ev.xclient.message_type = wmatom[WMProtocols];
++		ev.xclient.format = 32;
++		ev.xclient.data.l[0] = proto;
++		ev.xclient.data.l[1] = CurrentTime;
++		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
++	}
++	return exists;
++}
++
++void
++setfocus(Client *c)
++{
++	if (!c->neverfocus) {
++		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
++		XChangeProperty(dpy, root, netatom[NetActiveWindow],
++			XA_WINDOW, 32, PropModeReplace,
++			(unsigned char *) &(c->win), 1);
++	}
++	sendevent(c, wmatom[WMTakeFocus]);
++}
++
++void
++setfullscreen(Client *c, int fullscreen)
++{
++	if (fullscreen && !c->isfullscreen) {
++		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
++		c->isfullscreen = 1;
++		c->oldstate = c->isfloating;
++		c->oldbw = c->bw;
++		c->bw = 0;
++		c->isfloating = 1;
++		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
++		XRaiseWindow(dpy, c->win);
++	} else if (!fullscreen && c->isfullscreen){
++		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++			PropModeReplace, (unsigned char*)0, 0);
++		c->isfullscreen = 0;
++		c->isfloating = c->oldstate;
++		c->bw = c->oldbw;
++		c->x = c->oldx;
++		c->y = c->oldy;
++		c->w = c->oldw;
++		c->h = c->oldh;
++		resizeclient(c, c->x, c->y, c->w, c->h);
++		arrange(c->mon);
++	}
++}
++
++void
++setlayout(const Arg *arg)
++{
++	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
++		selmon->sellt ^= 1;
++	if (arg && arg->v)
++		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
++	if (selmon->sel)
++		arrange(selmon);
++	else
++		drawbar(selmon);
++}
++
++/* arg > 1.0 will set mfact absolutely */
++void
++setmfact(const Arg *arg)
++{
++	float f;
++
++	if (!arg || !selmon->lt[selmon->sellt]->arrange)
++		return;
++	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
++	if (f < 0.05 || f > 0.95)
++		return;
++	selmon->mfact = f;
++	arrange(selmon);
++}
++
++void
++setup(void)
++{
++	int i;
++	XSetWindowAttributes wa;
++	Atom utf8string;
++
++	/* clean up any zombies immediately */
++	sigchld(0);
++
++	signal(SIGHUP, sighup);
++	signal(SIGTERM, sigterm);
++
++	/* init screen */
++	screen = DefaultScreen(dpy);
++	sw = DisplayWidth(dpy, screen);
++	sh = DisplayHeight(dpy, screen);
++	root = RootWindow(dpy, screen);
++	drw = drw_create(dpy, screen, root, sw, sh);
++	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
++		die("no fonts could be loaded.");
++	lrpad = drw->fonts->h;
++	bh = user_bh ? user_bh : drw->fonts->h + 2;
++	updategeom();
++	/* init atoms */
++	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
++	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
++	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
++	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
++	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
++	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
++	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
++	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
++	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
++	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
++	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
++	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
++	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
++	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
++	/* init cursors */
++	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
++	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
++	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
++	/* init appearance */
++	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
++	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
++	for (i = 0; i < LENGTH(colors); i++)
++		scheme[i] = drw_scm_create(drw, colors[i], 3);
++	/* init bars */
++	updatebars();
++	updatestatus();
++	/* supporting window for NetWMCheck */
++	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
++	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
++		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
++		PropModeReplace, (unsigned char *) "dwm", 3);
++	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
++		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
++	/* EWMH support per view */
++	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
++		PropModeReplace, (unsigned char *) netatom, NetLast);
++	XDeleteProperty(dpy, root, netatom[NetClientList]);
++	/* select events */
++	wa.cursor = cursor[CurNormal]->cursor;
++	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
++		|ButtonPressMask|PointerMotionMask|EnterWindowMask
++		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
++	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
++	XSelectInput(dpy, root, wa.event_mask);
++	grabkeys();
++	focus(NULL);
++}
++
++
++void
++seturgent(Client *c, int urg)
++{
++	XWMHints *wmh;
++
++	c->isurgent = urg;
++	if (!(wmh = XGetWMHints(dpy, c->win)))
++		return;
++	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
++	XSetWMHints(dpy, c->win, wmh);
++	XFree(wmh);
++}
++
++void
++shiftviewclients(const Arg *arg)
++{
++	Arg shifted;
++	Client *c;
++	unsigned int tagmask = 0;
++
++	for (c = selmon->clients; c; c = c->next)
++		#if SCRATCHPADS_PATCH
++		if (!(c->tags & SPTAGMASK))
++			tagmask = tagmask | c->tags;
++		#else
++		tagmask = tagmask | c->tags;
++		#endif // SCRATCHPADS_PATCH
++
++	#if SCRATCHPADS_PATCH
++	shifted.ui = selmon->tagset[selmon->seltags] & ~SPTAGMASK;
++	#else
++	shifted.ui = selmon->tagset[selmon->seltags];
++	#endif // SCRATCHPADS_PATCH
++	if (arg->i > 0) // left circular shift
++		do {
++			shifted.ui = (shifted.ui << arg->i)
++			   | (shifted.ui >> (LENGTH(tags) - arg->i));
++			#if SCRATCHPADS_PATCH
++			shifted.ui &= ~SPTAGMASK;
++			#endif // SCRATCHPADS_PATCH
++		} while (tagmask && !(shifted.ui & tagmask));
++	else // right circular shift
++		do {
++			shifted.ui = (shifted.ui >> (- arg->i)
++			   | shifted.ui << (LENGTH(tags) + arg->i));
++			#if SCRATCHPADS_PATCH
++			shifted.ui &= ~SPTAGMASK;
++			#endif // SCRATCHPADS_PATCH
++		} while (tagmask && !(shifted.ui & tagmask));
++
++	view(&shifted);
++}
++
++void
++showhide(Client *c)
++{
++	if (!c)
++		return;
++	if (ISVISIBLE(c)) {
++		/* show clients top down */
++		XMoveWindow(dpy, c->win, c->x, c->y);
++		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
++			resize(c, c->x, c->y, c->w, c->h, 0);
++		showhide(c->snext);
++	} else {
++		/* hide clients bottom up */
++		showhide(c->snext);
++		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
++	}
++}
++
++void
++sigchld(int unused)
++{
++	if (signal(SIGCHLD, sigchld) == SIG_ERR)
++		die("can't install SIGCHLD handler:");
++	while (0 < waitpid(-1, NULL, WNOHANG));
++}
++
++void
++sighup(int unused)
++{
++	Arg a = {.i = 1};
++	quit(&a);
++}
++
++void
++sigterm(int unused)
++{
++	Arg a = {.i = 0};
++	quit(&a);
++}
++
++void
++spawn(const Arg *arg)
++{
++	if (arg->v == dmenucmd)
++		dmenumon[0] = '0' + selmon->num;
++	if (fork() == 0) {
++		if (dpy)
++			close(ConnectionNumber(dpy));
++		setsid();
++		execvp(((char **)arg->v)[0], (char **)arg->v);
++		fprintf(stderr, "dwm: execvp %s", ((char **)arg->v)[0]);
++		perror(" failed");
++		exit(EXIT_SUCCESS);
++	}
++}
++
++void
++tag(const Arg *arg)
++{
++	if (selmon->sel && arg->ui & TAGMASK) {
++		selmon->sel->tags = arg->ui & TAGMASK;
++		focus(NULL);
++		arrange(selmon);
++	}
++}
++
++void
++tagmon(const Arg *arg)
++{
++	if (!selmon->sel || !mons->next)
++		return;
++	sendmon(selmon->sel, dirtomon(arg->i));
++}
++
++void
++togglebar(const Arg *arg)
++{
++	selmon->showbar = !selmon->showbar;
++	updatebarpos(selmon);
++	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
++	arrange(selmon);
++}
++
++void
++togglefloating(const Arg *arg)
++{
++	if (!selmon->sel)
++		return;
++	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
++		return;
++	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
++	if (selmon->sel->isfloating)
++		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
++			selmon->sel->w, selmon->sel->h, 0);
++	arrange(selmon);
++}
++
++void
++togglefullscr(const Arg *arg)
++{
++  if(selmon->sel)
++    setfullscreen(selmon->sel, !selmon->sel->isfullscreen);
++}
++
++void
++toggletag(const Arg *arg)
++{
++	unsigned int newtags;
++
++	if (!selmon->sel)
++		return;
++	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
++	if (newtags) {
++		selmon->sel->tags = newtags;
++		focus(NULL);
++		arrange(selmon);
++	}
++}
++
++void
++toggleview(const Arg *arg)
++{
++	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++
++	if (newtagset) {
++		selmon->tagset[selmon->seltags] = newtagset;
++		focus(NULL);
++		arrange(selmon);
++	}
++}
++
++void
++unfocus(Client *c, int setfocus)
++{
++	if (!c)
++		return;
++	grabbuttons(c, 0);
++	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
++	if (setfocus) {
++		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
++		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
++	}
++}
++
++void
++unmanage(Client *c, int destroyed)
++{
++	Monitor *m = c->mon;
++	XWindowChanges wc;
++
++	if (c->swallowing) {
++		unswallow(c);
++		return;
++	}
++
++	Client *s = swallowingclient(c->win);
++	if (s) {
++		free(s->swallowing);
++		s->swallowing = NULL;
++		arrange(m);
++		focus(NULL);
++		return;
++	}
++
++	detach(c);
++	detachstack(c);
++	if (!destroyed) {
++		wc.border_width = c->oldbw;
++		XGrabServer(dpy); /* avoid race conditions */
++		XSetErrorHandler(xerrordummy);
++		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
++		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
++		setclientstate(c, WithdrawnState);
++		XSync(dpy, False);
++		XSetErrorHandler(xerror);
++		XUngrabServer(dpy);
++	}
++	free(c);
++
++	if (!s) {
++		arrange(m);
++		focus(NULL);
++		updateclientlist();
++	}
++}
++
++void
++unmapnotify(XEvent *e)
++{
++	Client *c;
++	XUnmapEvent *ev = &e->xunmap;
++
++	if ((c = wintoclient(ev->window))) {
++		if (ev->send_event)
++			setclientstate(c, WithdrawnState);
++		else
++			unmanage(c, 0);
++	}
++}
++
++void
++updatebars(void)
++{
++	Monitor *m;
++	XSetWindowAttributes wa = {
++		.override_redirect = True,
++		.background_pixmap = ParentRelative,
++		.event_mask = ButtonPressMask|ExposureMask
++	};
++	XClassHint ch = {"dwm", "dwm"};
++	for (m = mons; m; m = m->next) {
++		if (m->barwin)
++			continue;
++		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
++				CopyFromParent, DefaultVisual(dpy, screen),
++				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
++		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
++		XMapRaised(dpy, m->barwin);
++		XSetClassHint(dpy, m->barwin, &ch);
++	}
++}
++
++void
++updatebarpos(Monitor *m)
++{
++	m->wy = m->my;
++	m->wh = m->mh;
++	if (m->showbar) {
++		m->wh -= bh;
++		m->by = m->topbar ? m->wy : m->wy + m->wh;
++		m->wy = m->topbar ? m->wy + bh : m->wy;
++	} else
++		m->by = -bh;
++}
++
++void
++updateclientlist()
++{
++	Client *c;
++	Monitor *m;
++
++	XDeleteProperty(dpy, root, netatom[NetClientList]);
++	for (m = mons; m; m = m->next)
++		for (c = m->clients; c; c = c->next)
++			XChangeProperty(dpy, root, netatom[NetClientList],
++				XA_WINDOW, 32, PropModeAppend,
++				(unsigned char *) &(c->win), 1);
++}
++
++int
++updategeom(void)
++{
++	int dirty = 0;
++
++#ifdef XINERAMA
++	if (XineramaIsActive(dpy)) {
++		int i, j, n, nn;
++		Client *c;
++		Monitor *m;
++		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
++		XineramaScreenInfo *unique = NULL;
++
++		for (n = 0, m = mons; m; m = m->next, n++);
++		/* only consider unique geometries as separate screens */
++		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
++		for (i = 0, j = 0; i < nn; i++)
++			if (isuniquegeom(unique, j, &info[i]))
++				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
++		XFree(info);
++		nn = j;
++		if (n <= nn) { /* new monitors available */
++			for (i = 0; i < (nn - n); i++) {
++				for (m = mons; m && m->next; m = m->next);
++				if (m)
++					m->next = createmon();
++				else
++					mons = createmon();
++			}
++			for (i = 0, m = mons; i < nn && m; m = m->next, i++)
++				if (i >= n
++				|| unique[i].x_org != m->mx || unique[i].y_org != m->my
++				|| unique[i].width != m->mw || unique[i].height != m->mh)
++				{
++					dirty = 1;
++					m->num = i;
++					m->mx = m->wx = unique[i].x_org;
++					m->my = m->wy = unique[i].y_org;
++					m->mw = m->ww = unique[i].width;
++					m->mh = m->wh = unique[i].height;
++					updatebarpos(m);
++				}
++		} else { /* less monitors available nn < n */
++			for (i = nn; i < n; i++) {
++				for (m = mons; m && m->next; m = m->next);
++				while ((c = m->clients)) {
++					dirty = 1;
++					m->clients = c->next;
++					detachstack(c);
++					c->mon = mons;
++					switch(attachdirection){
++					case 1:
++						attachabove(c);
++						break;
++					case 2:
++						attachaside(c);
++						break;
++					case 3:
++						attachbelow(c);
++						break;
++					case 4:
++						attachbottom(c);
++						break;
++					case 5:
++						attachtop(c);
++						break;
++					default:
++						attach(c);
++					}
++					attachstack(c);
++				}
++				if (m == selmon)
++					selmon = mons;
++				cleanupmon(m);
++			}
++		}
++		free(unique);
++	} else
++#endif /* XINERAMA */
++	{ /* default monitor setup */
++		if (!mons)
++			mons = createmon();
++		if (mons->mw != sw || mons->mh != sh) {
++			dirty = 1;
++			mons->mw = mons->ww = sw;
++			mons->mh = mons->wh = sh;
++			updatebarpos(mons);
++		}
++	}
++	if (dirty) {
++		selmon = mons;
++		selmon = wintomon(root);
++	}
++	return dirty;
++}
++
++void
++updatenumlockmask(void)
++{
++	unsigned int i, j;
++	XModifierKeymap *modmap;
++
++	numlockmask = 0;
++	modmap = XGetModifierMapping(dpy);
++	for (i = 0; i < 8; i++)
++		for (j = 0; j < modmap->max_keypermod; j++)
++			if (modmap->modifiermap[i * modmap->max_keypermod + j]
++				== XKeysymToKeycode(dpy, XK_Num_Lock))
++				numlockmask = (1 << i);
++	XFreeModifiermap(modmap);
++}
++
++void
++updatesizehints(Client *c)
++{
++	long msize;
++	XSizeHints size;
++
++	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
++		/* size is uninitialized, ensure that size.flags aren't used */
++		size.flags = PSize;
++	if (size.flags & PBaseSize) {
++		c->basew = size.base_width;
++		c->baseh = size.base_height;
++	} else if (size.flags & PMinSize) {
++		c->basew = size.min_width;
++		c->baseh = size.min_height;
++	} else
++		c->basew = c->baseh = 0;
++	if (size.flags & PResizeInc) {
++		c->incw = size.width_inc;
++		c->inch = size.height_inc;
++	} else
++		c->incw = c->inch = 0;
++	if (size.flags & PMaxSize) {
++		c->maxw = size.max_width;
++		c->maxh = size.max_height;
++	} else
++		c->maxw = c->maxh = 0;
++	if (size.flags & PMinSize) {
++		c->minw = size.min_width;
++		c->minh = size.min_height;
++	} else if (size.flags & PBaseSize) {
++		c->minw = size.base_width;
++		c->minh = size.base_height;
++	} else
++		c->minw = c->minh = 0;
++	if (size.flags & PAspect) {
++		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
++		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
++	} else
++		c->maxa = c->mina = 0.0;
++	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
++}
++
++void
++updatestatus(void)
++{
++	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
++		strcpy(stext, "dwm-"VERSION);
++	drawbar(selmon);
++}
++
++void
++updatetitle(Client *c)
++{
++	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
++		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
++	if (c->name[0] == '\0') /* hack to mark broken clients */
++		strcpy(c->name, broken);
++}
++
++void
++updatewindowtype(Client *c)
++{
++	Atom state = getatomprop(c, netatom[NetWMState]);
++	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
++
++	if (state == netatom[NetWMFullscreen])
++		setfullscreen(c, 1);
++	if (wtype == netatom[NetWMWindowTypeDialog])
++		c->isfloating = 1;
++}
++
++void
++updatewmhints(Client *c)
++{
++	XWMHints *wmh;
++
++	if ((wmh = XGetWMHints(dpy, c->win))) {
++		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
++			wmh->flags &= ~XUrgencyHint;
++			XSetWMHints(dpy, c->win, wmh);
++		} else {
++			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
++			if (c->isurgent)
++				XSetWindowBorder(dpy, c->win, scheme[SchemeUrg][ColBorder].pixel);
++		}
++		if (wmh->flags & InputHint)
++			c->neverfocus = !wmh->input;
++		else
++			c->neverfocus = 0;
++		XFree(wmh);
++	}
++}
++
++void
++view(const Arg *arg)
++{
++	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++		return;
++	selmon->seltags ^= 1; /* toggle sel tagset */
++	if (arg->ui & TAGMASK)
++		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++	focus(NULL);
++	arrange(selmon);
++}
++
++pid_t
++winpid(Window w)
++{
++
++	pid_t result = 0;
++
++#ifdef __linux__
++	xcb_res_client_id_spec_t spec = {0};
++	spec.client = w;
++	spec.mask = XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID;
++
++	xcb_generic_error_t *e = NULL;
++	xcb_res_query_client_ids_cookie_t c = xcb_res_query_client_ids(xcon, 1, &spec);
++	xcb_res_query_client_ids_reply_t *r = xcb_res_query_client_ids_reply(xcon, c, &e);
++
++	if (!r)
++		return (pid_t)0;
++
++	xcb_res_client_id_value_iterator_t i = xcb_res_query_client_ids_ids_iterator(r);
++	for (; i.rem; xcb_res_client_id_value_next(&i)) {
++		spec = i.data->spec;
++		if (spec.mask & XCB_RES_CLIENT_ID_MASK_LOCAL_CLIENT_PID) {
++			uint32_t *t = xcb_res_client_id_value_value(i.data);
++			result = *t;
++			break;
++		}
++	}
++
++	free(r);
++
++	if (result == (pid_t)-1)
++		result = 0;
++
++#endif /* __linux__ */
++
++#ifdef __OpenBSD__
++        Atom type;
++        int format;
++        unsigned long len, bytes;
++        unsigned char *prop;
++        pid_t ret;
++
++        if (XGetWindowProperty(dpy, w, XInternAtom(dpy, "_NET_WM_PID", 0), 0, 1, False, AnyPropertyType, &type, &format, &len, &bytes, &prop) != Success || !prop)
++               return 0;
++
++        ret = *(pid_t*)prop;
++        XFree(prop);
++        result = ret;
++
++#endif /* __OpenBSD__ */
++	return result;
++}
++
++pid_t
++getparentprocess(pid_t p)
++{
++	unsigned int v = 0;
++
++#ifdef __linux__
++	FILE *f;
++	char buf[256];
++	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
++
++	if (!(f = fopen(buf, "r")))
++		return 0;
++
++	fscanf(f, "%*u %*s %*c %u", &v);
++	fclose(f);
++#endif /* __linux__*/
++
++#ifdef __OpenBSD__
++	int n;
++	kvm_t *kd;
++	struct kinfo_proc *kp;
++
++	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, NULL);
++	if (!kd)
++		return 0;
++
++	kp = kvm_getprocs(kd, KERN_PROC_PID, p, sizeof(*kp), &n);
++	v = kp->p_ppid;
++#endif /* __OpenBSD__ */
++
++	return (pid_t)v;
++}
++
++int
++isdescprocess(pid_t p, pid_t c)
++{
++	while (p != c && c != 0)
++		c = getparentprocess(c);
++
++	return (int)c;
++}
++
++Client *
++termforwin(const Client *w)
++{
++	Client *c;
++	Monitor *m;
++
++	if (!w->pid || w->isterminal)
++		return NULL;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++swallowingclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next) {
++		for (c = m->clients; c; c = c->next) {
++			if (c->swallowing && c->swallowing->win == w)
++				return c;
++		}
++	}
++
++	return NULL;
++}
++
++Client *
++wintoclient(Window w)
++{
++	Client *c;
++	Monitor *m;
++
++	for (m = mons; m; m = m->next)
++		for (c = m->clients; c; c = c->next)
++			if (c->win == w)
++				return c;
++	return NULL;
++}
++
++Monitor *
++wintomon(Window w)
++{
++	int x, y;
++	Client *c;
++	Monitor *m;
++
++	if (w == root && getrootptr(&x, &y))
++		return recttomon(x, y, 1, 1);
++	for (m = mons; m; m = m->next)
++		if (w == m->barwin)
++			return m;
++	if ((c = wintoclient(w)))
++		return c->mon;
++	return selmon;
++}
++
++/* There's no way to check accesses to destroyed windows, thus those cases are
++ * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
++ * default error handler, which may call exit. */
++int
++xerror(Display *dpy, XErrorEvent *ee)
++{
++	if (ee->error_code == BadWindow
++	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
++	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
++	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
++	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
++	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
++	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
++	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
++	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
++		return 0;
++	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
++		ee->request_code, ee->error_code);
++	return xerrorxlib(dpy, ee); /* may call exit */
++}
++
++int
++xerrordummy(Display *dpy, XErrorEvent *ee)
++{
++	return 0;
++}
++
++/* Startup Error handler to check if another window manager
++ * is already running. */
++int
++xerrorstart(Display *dpy, XErrorEvent *ee)
++{
++	die("dwm: another window manager is already running");
++	return -1;
++}
++
++void
++zoom(const Arg *arg)
++{
++	Client *c = selmon->sel;
++
++	if (!selmon->lt[selmon->sellt]->arrange
++	|| (selmon->sel && selmon->sel->isfloating))
++		return;
++	if (c == nexttiled(selmon->clients))
++		if (!c || !(c = nexttiled(c->next)))
++			return;
++	pop(c);
++}
++
++int
++main(int argc, char *argv[])
++{
++	if (argc == 2 && !strcmp("-v", argv[1]))
++		die("dwm-"VERSION);
++	else if (argc != 1)
++		die("usage: dwm [-v]");
++	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
++		fputs("warning: no locale support\n", stderr);
++	if (!(dpy = XOpenDisplay(NULL)))
++		die("dwm: cannot open display");
++	if (!(xcon = XGetXCBConnection(dpy)))
++		die("dwm: cannot get xcb connection\n");
++	checkotherwm();
++	setup();
++#ifdef __OpenBSD__
++	if (pledge("stdio rpath proc exec ps", NULL) == -1)
++		die("pledge");
++#endif /* __OpenBSD__ */
++	scan();
++	runautostart();
++	run();
++	if(restart) execvp(argv[0], argv);
++	cleanup();
++	XCloseDisplay(dpy);
++	return EXIT_SUCCESS;
++}
+Les fichiers binaires /home/fuzzbox/Téléchargements/dwm/dwm.o et ./dwm.o sont différents
Les sous-répertoires /home/fuzzbox/Téléchargements/dwm/patches et ./patches sont identiques
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/pmk.sh" ./pmk.sh
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/pmk.sh"	1970-01-01 01:00:00.000000000 +0100
+++ ./pmk.sh	2021-01-14 12:01:27.645385019 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+rm config.h && make
Les fichiers binaires /home/fuzzbox/Téléchargements/dwm/util.o et ./util.o sont différents
diff --color -up --new-file "/home/fuzzbox/T\303\251l\303\251chargements/dwm/vanitygaps.c" ./vanitygaps.c
--- "/home/fuzzbox/T\303\251l\303\251chargements/dwm/vanitygaps.c"	1970-01-01 01:00:00.000000000 +0100
+++ ./vanitygaps.c	2021-01-14 12:01:27.645385019 +0100
@@ -0,0 +1,809 @@
+/* Key binding functions */
+static void defaultgaps(const Arg *arg);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+/* Layouts (delete the ones you do not need) */
+static void bstack(Monitor *m);
+static void bstackhoriz(Monitor *m);
+static void centeredmaster(Monitor *m);
+static void centeredfloatingmaster(Monitor *m);
+static void deck(Monitor *m);
+static void dwindle(Monitor *m);
+static void fibonacci(Monitor *m, int s);
+static void grid(Monitor *m);
+static void nrowgrid(Monitor *m);
+static void spiral(Monitor *m);
+static void tile(Monitor *m);
+/* Internals */
+static void getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc);
+static void getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr);
+static void setgaps(int oh, int ov, int ih, int iv);
+
+/* Settings */
+#if !PERTAG_PATCH
+static int enablegaps = 1;
+#endif // PERTAG_PATCH
+
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	selmon->gappoh = oh;
+	selmon->gappov = ov;
+	selmon->gappih = ih;
+	selmon->gappiv = iv;
+	arrange(selmon);
+}
+
+void
+togglegaps(const Arg *arg)
+{
+	#if PERTAG_PATCH
+	selmon->pertag->enablegaps[selmon->pertag->curtag] = !selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	enablegaps = !enablegaps;
+	#endif // PERTAG_PATCH
+	arrange(NULL);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+	setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+getgaps(Monitor *m, int *oh, int *ov, int *ih, int *iv, unsigned int *nc)
+{
+	unsigned int n, oe, ie;
+	#if PERTAG_PATCH
+	oe = ie = selmon->pertag->enablegaps[selmon->pertag->curtag];
+	#else
+	oe = ie = enablegaps;
+	#endif // PERTAG_PATCH
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	if (smartgaps && n == 1) {
+		oe = 0; // outer gaps disabled when only one client
+	}
+
+	*oh = m->gappoh*oe; // outer horizontal gap
+	*ov = m->gappov*oe; // outer vertical gap
+	*ih = m->gappih*ie; // inner horizontal gap
+	*iv = m->gappiv*ie; // inner vertical gap
+	*nc = n;            // number of clients
+}
+
+void
+getfacts(Monitor *m, int msize, int ssize, float *mf, float *sf, int *mr, int *sr)
+{
+	unsigned int n;
+	float mfacts, sfacts;
+	int mtotal = 0, stotal = 0;
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	mfacts = MIN(n, m->nmaster);
+	sfacts = n - m->nmaster;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (n < m->nmaster)
+			mtotal += msize / mfacts;
+		else
+			stotal += ssize / sfacts;
+
+	*mf = mfacts; // total factor of master area
+	*sf = sfacts; // total factor of stack area
+	*mr = msize - mtotal; // the remainder (rest) of pixels after an even master split
+	*sr = ssize - stotal; // the remainder (rest) of pixels after an even stack split
+}
+
+/***
+ * Layouts
+ */
+
+/*
+ * Bottomstack layout + gaps
+ * https://dwm.suckless.org/patches/bottomstack/
+ */
+static void
+bstack(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov - iv * (n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sx = mx;
+		sy = my + mh + ih;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+	}
+}
+
+static void
+bstackhoriz(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh;
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	mw = m->ww - 2*ov - iv * (MIN(n, m->nmaster) - 1);
+	sw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sh = (mh - ih) * (1 - m->mfact);
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		sh = m->wh - mh - 2*oh - ih * (n - m->nmaster);
+	}
+
+	getfacts(m, mw, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+	}
+}
+
+/*
+ * Centred master layout + gaps
+ * https://dwm.suckless.org/patches/centeredmaster/
+ */
+void
+centeredmaster(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int lx = 0, ly = 0, lw = 0, lh = 0;
+	int rx = 0, ry = 0, rw = 0, rh = 0;
+	float mfacts = 0, lfacts = 0, rfacts = 0;
+	int mtotal = 0, ltotal = 0, rtotal = 0;
+	int mrest = 0, lrest = 0, rrest = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* initialize areas */
+	mx = m->wx + ov;
+	my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * ((!m->nmaster ? n : MIN(n, m->nmaster)) - 1);
+	mw = m->ww - 2*ov;
+	lh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - 1);
+	rh = m->wh - 2*oh - ih * (((n - m->nmaster) / 2) - ((n - m->nmaster) % 2 ? 0 : 1));
+
+	if (m->nmaster && n > m->nmaster) {
+		/* go mfact box in the center if more than nmaster clients */
+		if (n - m->nmaster > 1) {
+			/* ||<-S->|<---M--->|<-S->|| */
+			mw = (m->ww - 2*ov - 2*iv) * m->mfact;
+			lw = (m->ww - mw - 2*ov - 2*iv) / 2;
+			rw = (m->ww - mw - 2*ov - 2*iv) - lw;
+			mx += lw + iv;
+		} else {
+			/* ||<---M--->|<-S->|| */
+			mw = (mw - iv) * m->mfact;
+			lw = 0;
+			rw = m->ww - mw - iv - 2*ov;
+		}
+		lx = m->wx + ov;
+		ly = m->wy + oh;
+		rx = mx + mw + iv;
+		ry = m->wy + oh;
+	}
+
+	/* calculate facts */
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
+		if (!m->nmaster || n < m->nmaster)
+			mfacts += 1;
+		else if ((n - m->nmaster) % 2)
+			lfacts += 1; // total factor of left hand stack area
+		else
+			rfacts += 1; // total factor of right hand stack area
+	}
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+		if (!m->nmaster || n < m->nmaster)
+			mtotal += mh / mfacts;
+		else if ((n - m->nmaster) % 2)
+			ltotal += lh / lfacts;
+		else
+			rtotal += rh / rfacts;
+
+	mrest = mh - mtotal;
+	lrest = lh - ltotal;
+	rrest = rh - rtotal;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (!m->nmaster || i < m->nmaster) {
+			/* nmaster clients are stacked vertically, in the center of the screen */
+			resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			/* stack clients are stacked vertically */
+			if ((i - m->nmaster) % 2 ) {
+				resize(c, lx, ly, lw - (2*c->bw), (lh / lfacts) + ((i - 2*m->nmaster) < 2*lrest ? 1 : 0) - (2*c->bw), 0);
+				ly += HEIGHT(c) + ih;
+			} else {
+				resize(c, rx, ry, rw - (2*c->bw), (rh / rfacts) + ((i - 2*m->nmaster) < 2*rrest ? 1 : 0) - (2*c->bw), 0);
+				ry += HEIGHT(c) + ih;
+			}
+		}
+	}
+}
+
+void
+centeredfloatingmaster(Monitor *m)
+{
+	unsigned int i, n;
+	float mfacts, sfacts;
+	float mivf = 1.0; // master inner vertical gap factor
+	int oh, ov, ih, iv, mrest, srest;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	mw = m->ww - 2*ov - iv*(n - 1);
+	sw = m->ww - 2*ov - iv*(n - m->nmaster - 1);
+
+	if (m->nmaster && n > m->nmaster) {
+		mivf = 0.8;
+		/* go mfact box in the center if more than nmaster clients */
+		if (m->ww > m->wh) {
+			mw = m->ww * m->mfact - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * 0.9;
+		} else {
+			mw = m->ww * 0.9 - iv*mivf*(MIN(n, m->nmaster) - 1);
+			mh = m->wh * m->mfact;
+		}
+		mx = m->wx + (m->ww - mw) / 2;
+		my = m->wy + (m->wh - mh - 2*oh) / 2;
+
+		sx = m->wx + ov;
+		sy = m->wy + oh;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mw, sw, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			/* nmaster clients are stacked horizontally, in the center of the screen */
+			resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv*mivf;
+		} else {
+			/* stack clients are stacked horizontally */
+			resize(c, sx, sy, (sw / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * Deck layout + gaps
+ * https://dwm.suckless.org/patches/deck/
+ */
+void
+deck(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+		sh = m->wh - 2*oh;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	if (n - m->nmaster > 0) /* override layout symbol */
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, "D %d", n - m->nmaster);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), sh - (2*c->bw), 0);
+		}
+}
+
+/*
+ * Fibonacci layout + gaps
+ * https://dwm.suckless.org/patches/fibonacci/
+ */
+void
+fibonacci(Monitor *m, int s)
+{
+	unsigned int i, n;
+	int nx, ny, nw, nh;
+	int oh, ov, ih, iv;
+	int nv, hrest = 0, wrest = 0, r = 1;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	nx = m->wx + ov;
+	ny = m->wy + oh;
+	nw = m->ww - 2*ov;
+	nh = m->wh - 2*oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+		if (r) {
+			if ((i % 2 && (nh - ih) / 2 <= (bh + 2*c->bw))
+			   || (!(i % 2) && (nw - iv) / 2 <= (bh + 2*c->bw))) {
+				r = 0;
+			}
+			if (r && i < n - 1) {
+				if (i % 2) {
+					nv = (nh - ih) / 2;
+					hrest = nh - 2*nv - ih;
+					nh = nv;
+				} else {
+					nv = (nw - iv) / 2;
+					wrest = nw - 2*nv - iv;
+					nw = nv;
+				}
+
+				if ((i % 4) == 2 && !s)
+					nx += nw + iv;
+				else if ((i % 4) == 3 && !s)
+					ny += nh + ih;
+			}
+
+			if ((i % 4) == 0) {
+				if (s) {
+					ny += nh + ih;
+					nh += hrest;
+				}
+				else {
+					nh -= hrest;
+					ny -= nh + ih;
+				}
+			}
+			else if ((i % 4) == 1) {
+				nx += nw + iv;
+				nw += wrest;
+			}
+			else if ((i % 4) == 2) {
+				ny += nh + ih;
+				nh += hrest;
+				if (i < n - 1)
+					nw += wrest;
+			}
+			else if ((i % 4) == 3) {
+				if (s) {
+					nx += nw + iv;
+					nw -= wrest;
+				} else {
+					nw -= wrest;
+					nx -= nw + iv;
+					nh += hrest;
+				}
+			}
+			if (i == 0)	{
+				if (n != 1) {
+					nw = (m->ww - iv - 2*ov) - (m->ww - iv - 2*ov) * (1 - m->mfact);
+					wrest = 0;
+				}
+				ny = m->wy + oh;
+			}
+			else if (i == 1)
+				nw = m->ww - nw - iv - 2*ov;
+			i++;
+		}
+
+		resize(c, nx, ny, nw - (2*c->bw), nh - (2*c->bw), False);
+	}
+}
+
+void
+dwindle(Monitor *m)
+{
+	fibonacci(m, 1);
+}
+
+void
+spiral(Monitor *m)
+{
+	fibonacci(m, 0);
+}
+
+/*
+ * Gappless grid layout + gaps (ironically)
+ * https://dwm.suckless.org/patches/gaplessgrid/
+ */
+void
+gaplessgrid(Monitor *m)
+{
+	unsigned int i, n;
+	int x, y, cols, rows, ch, cw, cn, rn, rrest, crest; // counters
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	/* grid dimensions */
+	for (cols = 0; cols <= n/2; cols++)
+		if (cols*cols >= n)
+			break;
+	if (n == 5) /* set layout against the general calculation: not 1:2:2, but 2:3 */
+		cols = 2;
+	rows = n/cols;
+	cn = rn = 0; // reset column no, row no, client count
+
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / cols;
+	rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	crest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	x = m->wx + ov;
+	y = m->wy + oh;
+
+	for (i = 0, c = nexttiled(m->clients); c; i++, c = nexttiled(c->next)) {
+		if (i/rows + 1 > cols - n%cols) {
+			rows = n/cols + 1;
+			ch = (m->wh - 2*oh - ih * (rows - 1)) / rows;
+			rrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+		}
+		resize(c,
+			x,
+			y + rn*(ch + ih) + MIN(rn, rrest),
+			cw + (cn < crest ? 1 : 0) - 2*c->bw,
+			ch + (rn < rrest ? 1 : 0) - 2*c->bw,
+			0);
+		rn++;
+		if (rn >= rows) {
+			rn = 0;
+			x += cw + ih + (cn < crest ? 1 : 0);
+			cn++;
+		}
+	}
+}
+
+/*
+ * Gridmode layout + gaps
+ * https://dwm.suckless.org/patches/gridmode/
+ */
+void
+grid(Monitor *m)
+{
+	unsigned int i, n;
+	int cx, cy, cw, ch, cc, cr, chrest, cwrest, cols, rows;
+	int oh, ov, ih, iv;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* grid dimensions */
+	for (rows = 0; rows <= n/2; rows++)
+		if (rows*rows >= n)
+			break;
+	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+
+	/* window geoms (cell height/width) */
+	ch = (m->wh - 2*oh - ih * (rows - 1)) / (rows ? rows : 1);
+	cw = (m->ww - 2*ov - iv * (cols - 1)) / (cols ? cols : 1);
+	chrest = (m->wh - 2*oh - ih * (rows - 1)) - ch * rows;
+	cwrest = (m->ww - 2*ov - iv * (cols - 1)) - cw * cols;
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		cc = i / rows;
+		cr = i % rows;
+		cx = m->wx + ov + cc * (cw + iv) + MIN(cc, cwrest);
+		cy = m->wy + oh + cr * (ch + ih) + MIN(cr, chrest);
+		resize(c, cx, cy, cw + (cc < cwrest ? 1 : 0) - 2*c->bw, ch + (cr < chrest ? 1 : 0) - 2*c->bw, False);
+	}
+}
+
+/*
+ * Horizontal grid layout + gaps
+ * https://dwm.suckless.org/patches/horizgrid/
+ */
+void
+horizgrid(Monitor *m) {
+	Client *c;
+	unsigned int n, i;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	int ntop, nbottom = 1;
+	float mfacts, sfacts;
+	int mrest, srest;
+
+	/* Count windows */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	if (n <= 2)
+		ntop = n;
+	else {
+		ntop = n / 2;
+		nbottom = n - ntop;
+	}
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	sh = mh = m->wh - 2*oh;
+	sw = mw = m->ww - 2*ov;
+
+	if (n > ntop) {
+		sh = (mh - ih) / 2;
+		mh = mh - ih - sh;
+		sy = my + mh + ih;
+		mw = m->ww - 2*ov - iv * (ntop - 1);
+		sw = m->ww - 2*ov - iv * (nbottom - 1);
+	}
+
+	mfacts = ntop;
+	sfacts = nbottom;
+	mrest = mw - (mw / ntop) * ntop;
+	srest = sw - (sw / nbottom) * nbottom;
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < ntop) {
+			resize(c, mx, my, (mw / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), mh - (2*c->bw), 0);
+			mx += WIDTH(c) + iv;
+		} else {
+			resize(c, sx, sy, (sw / sfacts) + ((i - ntop) < srest ? 1 : 0) - (2*c->bw), sh - (2*c->bw), 0);
+			sx += WIDTH(c) + iv;
+		}
+}
+
+/*
+ * nrowgrid layout + gaps
+ * https://dwm.suckless.org/patches/nrowgrid/
+ */
+void
+nrowgrid(Monitor *m)
+{
+	unsigned int n;
+	int ri = 0, ci = 0;  /* counters */
+	int oh, ov, ih, iv;                         /* vanitygap settings */
+	unsigned int cx, cy, cw, ch;                /* client geometry */
+	unsigned int uw = 0, uh = 0, uc = 0;        /* utilization trackers */
+	unsigned int cols, rows = m->nmaster + 1;
+	Client *c;
+
+	/* count clients */
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+
+	/* nothing to do here */
+	if (n == 0)
+		return;
+
+	/* force 2 clients to always split vertically */
+	if (FORCE_VSPLIT && n == 2)
+		rows = 1;
+
+	/* never allow empty rows */
+	if (n < rows)
+		rows = n;
+
+	/* define first row */
+	cols = n / rows;
+	uc = cols;
+	cy = m->wy + oh;
+	ch = (m->wh - 2*oh - ih*(rows - 1)) / rows;
+	uh = ch;
+
+	for (c = nexttiled(m->clients); c; c = nexttiled(c->next), ci++) {
+		if (ci == cols) {
+			uw = 0;
+			ci = 0;
+			ri++;
+
+			/* next row */
+			cols = (n - uc) / (rows - ri);
+			uc += cols;
+			cy = m->wy + oh + uh + ih;
+			uh += ch + ih;
+		}
+
+		cx = m->wx + ov + uw;
+		cw = (m->ww - 2*ov - uw) / (cols - ci);
+		uw += cw + iv;
+
+		resize(c, cx, cy, cw - (2*c->bw), ch - (2*c->bw), 0);
+	}
+}
+
+/*
+ * Default tile layout + gaps
+ */
+static void
+tile(Monitor *m)
+{
+	unsigned int i, n;
+	int oh, ov, ih, iv;
+	int mx = 0, my = 0, mh = 0, mw = 0;
+	int sx = 0, sy = 0, sh = 0, sw = 0;
+	float mfacts, sfacts;
+	int mrest, srest;
+	Client *c;
+
+	getgaps(m, &oh, &ov, &ih, &iv, &n);
+	if (n == 0)
+		return;
+
+	sx = mx = m->wx + ov;
+	sy = my = m->wy + oh;
+	mh = m->wh - 2*oh - ih * (MIN(n, m->nmaster) - 1);
+	sh = m->wh - 2*oh - ih * (n - m->nmaster - 1);
+	sw = mw = m->ww - 2*ov;
+
+	if (m->nmaster && n > m->nmaster) {
+		sw = (mw - iv) * (1 - m->mfact);
+		mw = mw - iv - sw;
+		sx = mx + mw + iv;
+	}
+
+	getfacts(m, mh, sh, &mfacts, &sfacts, &mrest, &srest);
+
+	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+		if (i < m->nmaster) {
+			resize(c, mx, my, mw - (2*c->bw), (mh / mfacts) + (i < mrest ? 1 : 0) - (2*c->bw), 0);
+			my += HEIGHT(c) + ih;
+		} else {
+			resize(c, sx, sy, sw - (2*c->bw), (sh / sfacts) + ((i - m->nmaster) < srest ? 1 : 0) - (2*c->bw), 0);
+			sy += HEIGHT(c) + ih;
+		}
+}
\ Pas de fin de ligne à la fin du fichier
